<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico><title>Using Slate UI Classes from C++ - Unreal Engine Development Notes</title><meta name=author content="John Farrow"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="unreal engine,slate,c++"><meta property="og:title" content="Using Slate UI Classes from C++"><meta name=twitter:title content="Using Slate UI Classes from C++"><meta property="og:type" content="article"><meta property="og:url" content="https://johnjfarrow.github.io/posts/slate/"><meta property="og:description" content="Notes on using the Slate UI classes in Unreal Engine 5.0"><meta name=twitter:description content="Notes on using the Slate UI classes in Unreal Engine 5.0"><meta property="og:image" content="https://johnjfarrow.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://johnjfarrow.github.io/img/og.png"><meta property="article:published_time" content="2022-06-25T16:02:55+12:00"><meta property="article:modified_time" content="2022-06-25T16:02:55+12:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://johnjfarrow.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://johnjfarrow.github.io>Unreal Engine Development Notes</a>
<span class=title-sub>John Farrow</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://johnjfarrow.github.io/posts/slate/>Using Slate UI Classes from C++</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-06-25</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/unreal-engine>unreal engine</a>&nbsp;<a href=/tags/slate>slate</a>&nbsp;<a href=/tags/c++>c++</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=background>Background</h2><p>The notes here were made in the course of
creating a plugin which checks a project configuration
against a known-good collection of configuration settings, for
example to check that all the settings required for hardware
raytracing have their correct values, and have to options to display and change
the current settings, as shown here:</p><p><img class=img-zoomable src=/images/reflection_1.png alt></p><h2 id=overview>Overview</h2><p>Slate is a cross-platform user interface framework for creating tool and in-game UI.<br>Slate is used by the default code generated when
creating a new plugin.</p><p>When creating a new plugin the generated code for the main window of the plugin looks like this:</p><pre><code class=language-cpp>class SPresetBrowser : public SCompoundWidget
{
	SLATE_BEGIN_ARGS(SPresetBrowser)
	{
	}

	SLATE_END_ARGS()

	virtual ~SPresetBrowser();

	/** Widget constructor */
	void Construct(const FArguments&amp; Args, const TArray&lt; TSharedRef&lt;FPreset&gt; &gt;&amp; );
};
</code></pre><p>This shows two key features of Slate:</p><ol><li>The use of the SLATE_BEGIN_ARGS/SLATE_END_ARGS macros to declare arguments</li><li>The Construct() method which is where the actual UI objects are created.</li></ol><p>The code used in the examples below is based on the concept of a &lsquo;preset&rsquo;, which is a group
of editor properties like the ones shown in the image above. Each property
has fields which identify it such as the screen prompt in the project settings editor, and
the target value.</p><h3 id=object-hierarchy>Object Hierarchy</h3><p>The data objects for this plugin are listed in the table below. The data objects form a
hierarchy, and so do the UI widgets representing each data object.</p><table><thead><tr><th style=text-align:left>Data Object</th><th style=text-align:left>Details</th><th style=text-align:left>UI Widget</th></tr></thead><tbody><tr><td style=text-align:left>FPresetList</td><td style=text-align:left>Holds all of the data objects for the entire plugin</td><td style=text-align:left>SPresetBrowser</td></tr><tr><td style=text-align:left>FPreset</td><td style=text-align:left>Holds all of the data for one preset, including a list of properties and their desired values</td><td style=text-align:left>SPresetTile</td></tr><tr><td style=text-align:left>FPresetSetting</td><td style=text-align:left>Holds the data about one property such as name, type, desired value</td><td style=text-align:left>SPresetSettingTile</td></tr></tbody></table><p>The data objects have a hierarchy like this:</p><ul><li>FPresetList<ul><li>FPreset<ul><li>FPresetSetting</li></ul></li></ul></li></ul><p>And the corresponding UI widgets have a hierarchy like this:</p><ul><li>SPresetBrowser<ul><li>SPresetTile<ul><li>SPresetSettingTile</li></ul></li></ul></li></ul><p>Each of the UI widgets is a subclass of <code>SCompoundWidget</code>, and each overrides the Construct() method
to create its child widgets.</p><p>Each widget which has children has:</p><ul><li>a member which is a list of child data objects and</li><li>a member of type SListView which displays whatever is in the list of child data objects.</li></ul><p>Specifically:</p><ul><li>the SPresetBrowser has a list of FPreset objects and an SListView<fpreset> member</li><li>the SPresetTile has a list of FPresetSetting objects and an SListView<spresetsettingtile> member</li></ul><h3 id=the-construct-method>The Construct method</h3><p>The SPresetBrowser Construct method looks like this:</p><pre><code class=language-cpp>void SPresetBrowser::Construct(const FArguments&amp; Args, 
       const TArray&lt; TSharedRef&lt;FPreset&gt; &gt;&amp; InPresets )
{
	TSharedRef&lt;SBorder&gt; MainContent = SNew(SBorder)
		.BorderImage(FAppStyle::Get().GetBrush(&quot;Brushes.Panel&quot;))
		.Padding(0.f)
		[
			SNew(SVerticalBox)
			+ SVerticalBox::Slot()
			.VAlign(VAlign_Top)
			[
				SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this))
			]
		];

	ChildSlot
	[
		MainContent
	];
}
</code></pre><p>This shows the basic idea of constructing a UI declaratively using c++.</p><h4 id=the-snew-macro>The SNew macro</h4><p>This creates a widget, as in SNew(SVerticalBox) and makes it available for other calls such as VAlign() as shown above</p><h4 id=the-sassignnew-macro>The SAssignNew macro</h4><p>This creates a widget like SNew() does but also assigns it to a member shared pointer so it can be referenced later</p><h4 id=slots>Slots</h4><p>Many widgets have positions for child widgets. The positions are called slots. Slots are created and
accessed in different ways:</p><ul><li>Some widgets already have slots when the widget is constructed; like the SPresetBrowser itself which is created with a slot called ChildSlot which can be
accessed as shown above.</li><li>Widgets such as SHorizontalBox and SVerticalBox (as shown above) need to have each slot added using a call
to +SHorizontalBox::Slot() or +SVerticalBox::Slot().</li><li>some widgets have slots in specific places. The SGridPanel uses +SGridPanel::Slot(ColNum, RowNum) to add a
child widget in a specific place in the grid</li></ul><h4 id=styles>Styles</h4><p>The call to BorderImage() above calls <code>FAppStyle::Get()</code> to access a style object. Style objects contain brushes
(a rectangular area of a specific color), images, border detail and more. Style objects enable setting values such as
a font size or a widget color in one place (on the style) and reusing it in many places, ensuring a consistent look and feel
to the application. Making changes to the look of an application is easier because the styles are all in one place.</p><h4 id=construction-approaches>Construction approaches</h4><p>Widgets can be created and stored in variables, or created inline. The two code samples below do the same thing, the first
stores the SVerticalBox widget in a variable and then adds it to the child slot, the second creates it in the child
slot directly:</p><pre><code class=language-cpp>TSharedRef&lt;SBorder&gt; Variable = SNew(SVerticalBox)
	+ SVerticalBox::Slot()
	.VAlign(VAlign_Top)
	[
		SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this))
	]
];

ChildSlot
[
	Variable 
];
</code></pre><pre><code class=language-cpp>ChildSlot
[
	SNew(SVerticalBox)
		+ SVerticalBox::Slot()
		.VAlign(VAlign_Top)
		[
			SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this))
		]
	];
];
</code></pre><p>Some widgets automatically create child widgets. The SListView widget is constructed like this:</p><pre><code class=language-cpp>PresetListViewWidget =
	SNew(SListView&lt; TSharedRef&lt;FPreset&gt; &gt;)
	.SelectionMode(ESelectionMode::Single)
	.ListItemsSource(&amp;PresetListItems)
	.OnGenerateRow(this, &amp;SPresetTileList::PresetListView_OnGenerateRow)
	.ListViewStyle(FAppStyle::Get(), &quot;SimpleListView&quot;);
</code></pre><p>These lines:</p><pre><code class=language-cpp>.ListItemsSource(&amp;PresetListItems)
.OnGenerateRow(this, &amp;SPresetTileList::PresetListView_OnGenerateRow)
</code></pre><p>pass the SListView a list of FPreset objects, and tell it to call PresetListView_OnGenerateRow() once for every row.
The PresetListView_OnGenerateRow() method creates and returns the widget(s) which represent one row:</p><pre><code class=language-cpp>TSharedRef&lt;ITableRow&gt; SPresetTileList::PresetListView_OnGenerateRow(
	TSharedRef&lt;FPreset&gt; Item, 
	const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable)
{
	return
		SNew(STableRow&lt; TSharedRef&lt;FPreset&gt; &gt;, OwnerTable)
		[
			SNew(SPresetTile, SharedThis(this), Item)
		];
}
</code></pre><h2 id=buttons>Buttons</h2><p>Buttons are implemented using the SButton class and styled using the SButtonStyle class. This code
shows creation of a button widget:</p><pre><code class=language-cpp>const FText ApplyButtonLabel = LOCTEXT(&quot;WindowWidgetText&quot;, &quot;Apply&quot;);

SNew(SButton)
.ButtonStyle( FEditorPresetsPluginStyle::Get(), &quot;PresetTile.ApplyButtonStyle&quot; )
.HAlign(HAlign_Center)
.VAlign(VAlign_Center)
.IsEnabled_Lambda([this]() -&gt; bool
{
	return PresetSetting-&gt;EditorValueIsDifferent() || PresetSetting-&gt;bRevertable;
})
.ContentPadding(FMargin(4.0f, 4.0f))
.OnClicked_Raw(this, &amp;SPropertySettingTile::OnApplyButtonClicked)
[
	SAssignNew(ApplyRevertButtonLabel,STextBlock)
	.Text(ApplyButtonLabel)
	.Margin(2.0f)
]
</code></pre><p>This illustrates a number of interesting points:</p><h3 id=buttons-are-containers>Buttons are Containers</h3><p>The SButton object draws a rectangle on the screen. Any text on the button comes from
child widgets of the button. This part of the above code shows the creation of
a text block which contains the text which appears on the button:</p><pre><code class=language-cpp>[
	SAssignNew(ApplyRevertButtonLabel,STextBlock)
	.Text(ApplyButtonLabel)
	.Margin(2.0f)
]
</code></pre><h3 id=button-styles>Button Styles</h3><p>The style used here is created with the code below when the plugin is initialized. This code sets the
color to be used by the button when the button is in various states such as Normal, Hovered Over, and Disabled.
The style is added to the StyleInstance object along with other styles and can be retrieved using the
&ldquo;PresetTile.ApplyButtonStyle&rdquo; key.</p><pre><code class=language-cpp>void FEditorPresetsPluginStyle::Initialize()
{
	FColor ButtonColor = FColor::Green;
	FButtonStyle ApplyButtonStyle = FAppStyle::Get().GetWidgetStyle&lt; FButtonStyle &gt;(&quot;SimpleButton&quot;);
	ApplyButtonStyle.SetNormal(FSlateColorBrush(ButtonColor));
	ApplyButtonStyle.SetHovered(FSlateColorBrush(ButtonColor));
	ApplyButtonStyle.SetDisabled(FSlateColorBrush(FSlateColor::UseSubduedForeground()));
	ApplyButtonStyle.SetNormalForeground(FStyleColors::Black);
	ApplyButtonStyle.SetHoveredForeground(FStyleColors::Black);
	StyleInstance-&gt;Set(&quot;PresetTile.ApplyButtonStyle&quot;, ApplyButtonStyle);
}
</code></pre><p>To use the style specify the static StyleInstance object for the plugin and key &ldquo;PresetTile.ApplyButtonStyle&rdquo; like so:</p><pre><code class=language-cpp>SNew(SButton)
.ButtonStyle( FEditorPresetsPluginStyle::Get(), &quot;PresetTile.ApplyButtonStyle&quot; )
</code></pre><h3 id=callbacks-and-events>Callbacks and Events</h3><p>The lines</p><pre><code class=language-cpp>SNew(SButton)
.IsEnabled(true)
</code></pre><p>shows the simplest way of specifying a parameter to the IsEnabled method. Other ways exist such as:</p><p><code>IsEnabled(this, &FMedia::IsAutoDetectEnabled)</code> Takes a pointer to an object and a method to be called on that object. This version calls shared_from_this() on the object parameter to
make a shared pointer to the object. It will fail if that object is still being constructed because shared_from_this() cannot be called
on a partially constructed object. This method does have the advantage that it uses a shared pointer to keep the referenced object alive.</p><p><code>IsEnabled_Raw(this, &FMedia::IsAutoDetectEnabled)</code> Takes a pointer to an object and method to be called on that object. This version takes a raw pointer and will not call shared_from_this()
so can be called when the object has not finished construction.</p><p><code>IsEnabled_Lambda</code> Takes a lambda returning a bool, for example:</p><pre><code class=language-cpp>SNew(SButton)
.IsEnabled_Lambda([this]() -&gt; bool
{
	return PresetSetting-&gt;EditorValueIsDifferent();
})
</code></pre><p>This means the enabled state of the button can change when the data changes.</p><p><code>IsEnabled_Static(&FMedia::IsNotCustomEventOverride, FunctionEntryNodePtr)</code> Takes a static function and a parameter</p><p><code>IsEnabled_UObject(Item, &FMedia::GetOwnerIsEnabled)</code> Takes a pointer to a UObject and a member method</p><p><code>IsEnabled_UObject(this, &FMedia::IsImportEnabled, ContextObject)</code> Takes a reference to a method and an additional UObject parameter|</p><h3 id=events>Events</h3><p>This code shows a callback when a button is clicked:</p><pre><code class=language-cpp>SNew(SButton)
.OnClicked_Raw(this, &amp;SPropertySettingTile::OnApplyButtonClicked )
</code></pre><p>Like the Callbacks section above, there are many variations of the OnClicked() method taking different parameters.</p><p>The implementation of the OnApplyButtonClicked method looks like this:</p><pre><code class=language-cpp>FReply SPropertySettingTile::OnApplyButtonClicked()
{
	if (EditorValueWidget.IsValid())
	{
		EditorValueWidget-&gt;SetText(FText::FromString(PresetSetting-&gt;EditorValue));
	}
	return FReply::Handled();
}
</code></pre><p>The only special detail to note is that it returns an FReply object telling the editor whether the
click was handled or not.</p><h3 id=beware-of-logic-errors>Beware of Logic Errors</h3><p>The behaviour of a specific widget sometimes depends on the widget it is contained in.
For example this code creates an SListView widget which creates one row for each
of the ten entries in the <code>Data</code> collection:</p><pre><code class=language-cpp>SNew(SVerticalBox)
+ SVerticalBox::Slot()
.AutoHeight() 
[
	SNew(SListView&lt; TSharedRef&lt; DataClass &gt; &gt;)
	.ListItemsSource(&amp;Data)
	.SelectionMode(ESelectionMode::None)
	.OnGenerateRow(this, &amp;SPresetBrowser::OnGenerateRow)
	.ListViewStyle(FAppStyle::Get(), &quot;SimpleListView&quot;)
]
</code></pre><p>but the list view will display without a scrollbar. This is because there is a conflict between the way the height of the SListView is calculated
and the way the height of the containing SVerticalBox is calculated. The SListView needs to know the height of its container so it can calculate
its own height and hence the position of the scrollbar, but because <code>.AutoHeight()</code> is specified on the SVerticalBox the
height of the vertical box is in turn calculated. It is not possible to satisfy both these requirements.</p><h2 id=widget-reflector>Widget Reflector</h2><p>This tool is found in the Unreal Editor under Tools|Debug|Widget Reflector. It shows a windows like this:
<img class=img-zoomable src=/images/WidgetReflector_1.png alt></p><p>To use it click the &ldquo;Pick Hit-Testable Widgets&rdquo;, then click on a widget in your UI, then hit escape. The Widget Reflector
window will now show the hierarchy of widgets and their children like so:
<img class=img-zoomable src=/images/WidgetReflector_2.png alt></p><p>Picking a widget in the hierarchy will highlight it in the UI as shown in the above image by the green box around
the selected widget. You can also click on the &ldquo;Source&rdquo; column to jump to the line of code which created that widget.</p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#overview>Overview</a><ul><li><a href=#object-hierarchy>Object Hierarchy</a></li><li><a href=#the-construct-method>The Construct method</a></li></ul></li><li><a href=#buttons>Buttons</a><ul><li><a href=#buttons-are-containers>Buttons are Containers</a></li><li><a href=#button-styles>Button Styles</a></li><li><a href=#callbacks-and-events>Callbacks and Events</a></li><li><a href=#events>Events</a></li><li><a href=#beware-of-logic-errors>Beware of Logic Errors</a></li></ul></li><li><a href=#widget-reflector>Widget Reflector</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#overview>Overview</a><ul><li><a href=#object-hierarchy>Object Hierarchy</a></li><li><a href=#the-construct-method>The Construct method</a></li></ul></li><li><a href=#buttons>Buttons</a><ul><li><a href=#buttons-are-containers>Buttons are Containers</a></li><li><a href=#button-styles>Button Styles</a></li><li><a href=#callbacks-and-events>Callbacks and Events</a></li><li><a href=#events>Events</a></li><li><a href=#beware-of-logic-errors>Beware of Logic Errors</a></li></ul></li><li><a href=#widget-reflector>Widget Reflector</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2022
<a href=https://johnjfarrow.github.io>John Farrow</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>