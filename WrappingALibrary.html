<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Wrapping a third party library using an Unreal Engine Plugin | unrealcode.net</title>
<meta name="description" content="Wrapping a third party library using an Unreal Engine Plugin">
<meta charset="utf-8">
<link rel="stylesheet" href="./css/styles.css">
<link rel="stylesheet" href="./css/syntaxhighlightingstyles.css">
</head>
<body>
<div id="app" data-server-rendered="true">
<div class="theme-container">
</div>
<header class="navbar">
<div class="sidebar-button">
</div>
<a href="index.html" aria-current="page" class="home-link router-link-exact-active router-link-active">
<span class="site-name">
unrealcode.net
</span>
</a>
<div class="links">
<nav class="nav-links can-hide">
<div class="nav-item">
<a href="index.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
Home
</a>
</div>
</nav>
</div>
</header>
<div class="sidebar-mask">
</div>
<aside class="sidebar">
<ul class="sidebar-links">
<li>
<section class="sidebar-group depth-0">
<p class="sidebar-heading open">
<span>
Wrapping a third party library using an Unreal Engine Plugin
</span>
</p>
<ul class="sidebar-links sidebar-group-items">
<li>
<a class="sidebar-link" href="#introduction">
Introduction
</a>
</li>
<li>
<a class="sidebar-link" href="#understanding-import-libraries">
Understanding Import Libraries
</a>
<ul class="sidebar-sub-headers">
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#minor-details">
Minor Details
</a>
</li>
</ul>
</li>
<li>
<a class="sidebar-link" href="#plugin-directory-structures">
Plugin Directory Structures
</a>
</li>
<li>
<a class="sidebar-link" href="#plugin-build-files">
Plugin Build Files
</a>
<ul class="sidebar-sub-headers">
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#files-we-don't-need">
Files we don't need
</a>
</li>
</ul>
</li>
<li>
<a class="sidebar-link" href="#binary-files">
Binary files
</a>
</li>
<li>
<a class="sidebar-link" href="#import-libraries">
Import Libraries
</a>
</li>
<li>
<a class="sidebar-link" href="#delayed-loading-of-dlls">
Delayed Loading of DLLs
</a>
</li>
<li>
<a class="sidebar-link" href="#delayed-load-dll-ordering">
Delayed Load DLL Ordering
</a>
</li>
<li>
<a class="sidebar-link" href="#building-a-plugin-from-the-command-line">
Building a plugin from the command line
</a>
</li>
<li>
<a class="sidebar-link" href="#troubleshooting">
Troubleshooting
</a>
</li>
<li>
<a class="sidebar-link" href="#other-plugin-features">
Other plugin features
</a>
<ul class="sidebar-sub-headers">
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#include-paths">
Include Paths
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#alternative-names-for-debug-files">
Alternative names for debug files
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#defining-variables">
Defining variables
</a>
</li>
</ul>
</li>
<li>
<a class="sidebar-link" href="#references">
References
</a>
</li>
</ul>
</section>
</li>
</ul>
</aside>
<main class="page">
<div class="theme-default-content content__default">
<h1>Wrapping a third party library using an Unreal Engine Plugin</h1>
<h2 id="introduction">Introduction</h2>
<p>Unreal Engine supports plugins, which contain code and game content. They can also
wrap a third party library (a .dll file) and allow the functionality of
that library to be called  directly from C++
and indirectly using Blueprint objects which are part of the plugin.</p>
<p>In a previous article <a href="BuildingFFMPEG.html">here</a> we compiled the open source ffmpeg 
library.  Now we will create a plugin which wraps the ffmpeg library in a form
where it can be used in other Unreal Engine projects.</p>
<p>The point of this article is not to create an ffmpeg plugin, but to understand
what is involved in making a third party plugin and 
explain how to deal with some of the problems which might arise.</p>
<h2 id="understanding-import-libraries">Understanding Import Libraries</h2>
<p>When a DLL is compiled from C or C++ source code two files are created, one with the extension &quot;.dll&quot; and
one with the extension &quot;.lib&quot;.  The one with the .lib extension is the import library.</p>
<p>Typically a DLL contains a large number of symbols for all the functions and variables used in the code.  Only some
of these symbols are intended to be used by programs which load the DLL. These symbols
are <em>exported</em> from the DLL either by making them with  <code>__declspec(dllexport)</code> in the source
code or naming them in a separate .DEF file which is used as part of the compilation process.</p>
<p>The import library contains information about all of the exported symbols
from the DLL and is used in two ways:</p>
<ul>
<li> by the linker when a program is compiled and linked to resolve symbols imported from the DLL</li>
<li> at runtime to tell the linker which DLL supplies the exported symbol</li>
</ul>
<p>The .dll and .lib files are a pair and are distributed together in a plugin.</p>
<h4 id="minor-details">Minor Details</h4>
<p>Windows static libraries also have a .lib extension.  When using a DLL, symbols are resolved 
when the program is loaded.  When using a static library, symbols are resolved at compile time - the
needed parts of the static library are included in the executable file.  This has consequences including 
larger executable files and not being able to share code which resides in a DLL.</p>
<p>Linux does not use import libraries.  By default it exports all symbols in a .dll (usually a shared object .so file).  This
is a simpler approach but introduces its own complexities as thousands more symbols must be resolved at link time, and
sometimes they resolve in undesirable ways.</p>
<h2 id="plugin-directory-structures">Plugin Directory Structures</h2>
<p>Epic has this to say about directory structures:</p>
<blockquote>
<p>&quot;The Unreal Engine (UE) source code includes several third-party libraries, which are stored under UnrealEngine/Engine/Source/ThirdParty/.. This is a convention for engine modules, and not required. When developing plugins that use third-party libraries, it is more convenient to include the third-party software within the plugin directory.</p>
</blockquote>
<p>If you create a plugin from the UI, using Edit | Plugins | +Add | Third Party Library you end up with a plugin directory
structure which looks like this (for clarity I have removed the non-Windows directories):</p>
<p><img src="/images/plugin_001.png" alt="" /></p>
<h2 id="plugin-build-files">Plugin Build Files</h2>
<p>The directories shown above show how the generated code is split into two parts:</p>
<ul>
<li> the ThirdParty directory which contains files associated with the DLLs which the plugin wraps</li>
<li> the GeneratedExample module which contains module startup and shutdown code for the plugin</li>
</ul>
<p>The most important file is GeneratedExampleLibrary.Build.cs.  This contains (only the 
Windows content is shown):</p>
<div class="csharp"><pre>
<span class="keyword">using</span> System.IO;
<span class="keyword">using</span> UnrealBuildTool;

<span class="keyword">public</span> <span class="keyword">class</span> GeneratedExampleLibrary : ModuleRules
{
	<span class="keyword">public</span> GeneratedExampleLibrary(ReadOnlyTargetRules Target) : <span class="keyword">base</span>(Target)
	{
		Type = ModuleType.External;

		<span class="keyword">if</span> (Target.Platform == UnrealTargetPlatform.Win64)
		{
			<span class="comment">// Add the import library</span>
			PublicAdditionalLibraries.Add(
				Path.Combine(ModuleDirectory, <span class="string">&quot;x64&quot;</span>, <span class="string">&quot;Release&quot;</span>, <span class="string">&quot;ExampleLibrary.lib&quot;</span>));

			<span class="comment">// Delay-load the DLL, so we can load it from the right place first</span>
			PublicDelayLoadDLLs.Add(<span class="string">&quot;ExampleLibrary.dll&quot;</span>);

			<span class="comment">// Ensure that the DLL is staged along with the executable</span>
			RuntimeDependencies.Add(
		<span class="string">&quot;$(PluginDir)/Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ExampleLibrary.dll&quot;</span>);
   		 }
	}
}
</pre></div><h3 id="files-we-dont-need">Files we don't need</h3>
<p>The GeneratedExampleLibrary.Build.cs contains this line:</p>
<div class="csharp"><pre>
 Type = ModuleType.External;
</pre></div>
<p>This indicates the ThirdParty module does not contain source which Unreal needs to build, it only contains
the DLLs - these are assumed to be built outside of Unreal and do not need to be compiled by Unreal.</p>
<p>But the plugin generator has added ExampleLibrary.cpp and ExampleLibrary.h.  These files <em>were</em> used once
to generate the ExampleLibrary.dll and ExampleLibrary.lib <em>when the project was created</em>.  But now ExampleLibrary.cpp
is not used - if you change it nothing happens - ExampleLibrary.dll and ExampleLibrary.lib do not get rebuilt.</p>
<p>ExampleLibrary.h is used in the GeneratedExample module, where it runs a test
just to show in the module startup code (in <code>FGeneratedExampleModule::StartupModule()</code>)
that the function <code>ExampleLibraryFunction()</code> which is in the ExampleLibrary.dll can be called.</p>
<p>If we want to add our own DLLs to the project, using it as a starting point, we can delete </p>
<ul>
<li> ExampleLibrary.h</li>
<li> ExampleLibrary.cpp</li>
<li> everything in <code>FGeneratedExampleModule::StartupModule()</code></li>
</ul>
<h2 id="binary-files">Binary files</h2>
<p>It is important to understand that the file Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ExampleLibrary.dll was put in that directory by the plugin example creation code in the Unreal Editor when we created the plugin. It is not
put there by the build process.  Although it is a copy of the file in ThirdParty\GeneratedExampleCode\x64\Release the project as generated
does not have a  mechanism to automatically copy it.  If we delete Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ExampleLibrary.dll
and rebuild the project, it does not get regenerated or copied.</p>
<p>These lines in the .Build.cs files suggest the ExampleLibrary.dll will be copied to the Binaries directory - but this is
not the case; a runtime dependency added in this way is only added if the file already exists under the Binaries directory:</p>
<div class="csharp"><pre>
<span class="comment">// Ensure that the DLL is staged along with the executable</span>
RuntimeDependencies.Add(
	 <span class="string">&quot;$(PluginDir)/Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ExampleLibrary.dll&quot;</span>);
</pre></div>
<p>However you can copy a DLL to the Binaries directory from somewhere else like this:</p>
<div class="csharp"><pre>
RuntimeDependencies.Add(
      <span class="string">&quot;$(PluginDir)/Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ExampleLibrary.dll&quot;</span>, 
      Path.Combine(ModuleDirectory, <span class="string">&quot;x64&quot;</span>, <span class="string">&quot;Release&quot;</span>, <span class="string">&quot;ExampleLibrary.dll&quot;</span>) );
</pre></div>
<p>If you do this the file will be copied when you build in the editor.  This will also 
put the DLL in the Binaries directory when you package the plugin.</p>
<p>If the DLLs you want to distribute in the plugin are installed elsewhere on your system you can reference them
in a similar way.  These lines show how to add runtime dependencies for all the .dll files in the
directory d:\tools\ffmpeg6\installed\bin:</p>
<div class="csharp"><pre>
DirectoryInfo d = <span class="keyword">new</span> DirectoryInfo(<span class="stringCSharpVerbatim">@&quot;d:\tools\ffmpeg6\installed\bin&quot;</span>); 

FileInfo[] Files = d.GetFiles(<span class="string">&quot;*.dll&quot;</span>);
<span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> Files)
{
	<span class="keyword">string</span> FileName = Path.GetFileName(file.FullName);  
	RuntimeDependencies.Add(
		<span class="string">&quot;$(PluginDir)/Binaries/ThirdParty/GeneratedExampleLibrary/Win64/&quot;</span> + FileName, 
		file.FullName);
}
</pre></div>
<p>When this code is compiled, or the plugin is packaged, all the .dll files in d:\tools\ffmpeg6\installed\bin
will be copied to the /Binaries/ThirdParty/GeneratedExampleLibrary/Win64/ directory.</p>
<h2 id="import-libraries">Import Libraries</h2>
<p>To add an .lib file to the project it needs to be added to the additional libraries collection
which Unreal uses to generate its compile commands.  This is done by 
adding it to the PublicAdditionalLibraries collection in the GeneratedExampleLibrary.Build.cs like this:</p>
<div class="csharp"><pre>
DirectoryInfo d = <span class="keyword">new</span> DirectoryInfo(<span class="stringCSharpVerbatim">@&quot;d:\tools\ffmpeg6\installed\bin&quot;</span>); 

FileInfo[] Libs = d.GetFiles(<span class="string">&quot;*.lib&quot;</span>);
<span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> Libs)
{
	PublicAdditionalLibraries.Add( file.FullName );
}
</pre></div>
<p>The above code makes all the .lib file in d:\tools\ffmpeg6\installed\bin available to
the project.  </p>
<p>Its important to realise that Unreal does not use the project configuration 
of Visual Studio.  In Visual Studio you can configure project paths in the 
project properties dialog:</p>
<p><img src="/images/plugin_003.png" alt="" /></p>
<p>This has no effect! Unreal does not use the paths set here, it uses the paths set in the 
.Build.cs files to create its compile commands.</p>
<h2 id="delayed-loading-of-dlls">Delayed Loading of DLLs</h2>
<p>When a normal Windows process tries to load a .dll file it looks in places specified
by the PATH environment variable. Unreal projects have their own idea of where a .dll might be, so that look in different 
places.</p>
<p>If a .dll cannot be found, we see a dialog box like this:</p>
<p><img src="/images/plugin_004.png" alt="" /></p>
<p> And output like this in the Output window of Visual Studio:</p>
<pre><code>LogWindows: Failed to load 'D:/work/learn/PluginsGenerated/Plugins/GeneratedExample/Binaries/Win64/UnrealEditor-GeneratedExample.dll' (GetLastError=126)
LogWindows:   Missing import: avformat-60.dll
LogWindows:   Looked in: ../../../Engine/Binaries/Win64
LogWindows:   Looked in: D:\work\learn\PluginsGenerated\Binaries\Win64
LogWindows:   Looked in: D:\work\learn\PluginsGenerated\Plugins\GeneratedExample\Binaries\Win64
LogWindows:   Looked in: C:\Program Files\Epic Games\UE_5.1\Engine\Plugins\Editor\ModelingToolsEditorMode\Binaries\Win64
and another ~150 similar lines
</code></pre>
<p>Unreal by default looks in the Binaries\Win64 directory of every plugin, including:</p>
<ul>
<li> D:\work\learn\PluginsGenerated\Binaries\Win64</li>
<li> D:\work\learn\PluginsGenerated\Plugins\GeneratedExample\Binaries\Win64</li>
</ul>
<p>but not the Binaries directory of the ThirdParty module of our project</p>
<ul>
<li> D:\work\learn\PluginsGenerated\Plugins\GeneratedExample\Binaries\ThirdParty\GeneratedExampleLibrary\Win64</li>
</ul>
<p>So we can either:</p>
<ul>
<li> move the files to D:\work\learn\PluginsGenerated\Plugins\GeneratedExample\Binaries\Win64 by changing the
.Build.cs to:</li>
</ul>
<div class="csharp"><pre>
FileInfo[] Files = d.GetFiles(<span class="string">&quot;*.dll&quot;</span>);
<span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> Files)
{
	<span class="keyword">string</span> FileName = Path.GetFileName(file.FullName);
	RuntimeDependencies.Add( 
		<span class="string">&quot;$(PluginDir)/Binaries/Win64/&quot;</span> + FileName, 
		file.FullName);
}

FileInfo[] Libs = d.GetFiles(<span class="string">&quot;*.lib&quot;</span>);
<span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> Libs)
{
	PublicAdditionalLibraries.Add( file.FullName);
	RuntimeDependencies.Add(
		<span class="string">&quot;$(PluginDir)/Binaries/Win64/&quot;</span> + FileName,
		file.FullName);
}
</pre></div>
<ul>
<li> or leave the files where they are and configure them for delayed loading.  </li>
</ul>
<p>To mark a .dll file for delayed load call <code>PublicDelayLoadDLLs.Add(DLLName)</code> like so:</p>
<div class="csharp"><pre>
FileInfo[] Files = d.GetFiles(<span class="string">&quot;*.dll&quot;</span>);
<span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> Files)
{
	<span class="keyword">string</span> FileName = Path.GetFileName(file.FullName);
	RuntimeDependencies.Add( 
		<span class="string">&quot;$(PluginDir)/Binaries/ThirdParty/GeneratedExampleLibrary/Win64/&quot;</span> + FileName, 
		file.FullName);
	PublicDelayLoadDLLs.Add(file.Name);
}
</pre></div>
<p>Note that the <code>PublicDelayLoadDLLs()</code> call takes just the file name not the path.</p>
<p>Delayed loading means before Unreal attempts to call a method in a DLL it gives
us a change to load the library ourselves using a call to 
<code>FPlatformProcess::GetDllHandle()</code>. </p>
<p>If our code calls <code>FPlatformProcess::GetDllHandle()</code> to load a DLL
<em>before any method from it is used</em>, we can load the DLL from any location and it will be used.</p>
<p>For example in the module startup of our plugin 
(in <code>FGeneratedExampleModule::StartupModule()</code>)
we could create a list of DLLs we want
to load and load each one using a call to ```FPlatformProcess::GetDllHandle()`` 
like this:</p>
<div class="csharp"><pre>
	<span class="keyword">const</span> FString DLLs[] = {
		<span class="string">&quot;avutil-58.dll&quot;</span>,
		<span class="string">&quot;swresample-4.dll&quot;</span>,
		<span class="string">&quot;libx264-164.dll&quot;</span>,
		<span class="string">&quot;avcodec-60.dll&quot;</span>,
		<span class="string">&quot;avformat-60.dll&quot;</span>
	};

	FString Dir = &quot;d:\\tools\\ffmpeg6\\installed\\bin\\&quot;;

	<span class="keyword">for</span> (<span class="keyword">const</span> FString&amp; DLL : DLLs)
	{
		FString Where = Dir + DLL;
		<span class="keyword">void</span>* Handle = FPlatformProcess::GetDllHandle(*Where);
		<span class="keyword">if</span> (!Handle)
		{
			UE_LOG(LogTemp, Error, TEXT(<span class="string">&quot;Failed to open %s&quot;</span>), *Where);
		}
	}

	avformat_network_init();
</pre></div>
<p>where <code>avformat_network_init()</code> is the ffmpeg call we to load from the DLL.</p>
<h2 id="delayed-load-dll-ordering">Delayed Load DLL Ordering</h2>
<p>In the above example we have this list of DLLs to load using <code>FPlatformProcess::GetDllHandle()</code>.</p>
<div class="csharp"><pre>
<span class="keyword">const</span> FString DLLs[] = {
	<span class="string">&quot;avutil-58.dll&quot;</span>,
	<span class="string">&quot;swresample-4.dll&quot;</span>,
	<span class="string">&quot;libx264-164.dll&quot;</span>,
	<span class="string">&quot;avcodec-60.dll&quot;</span>,
	<span class="string">&quot;avformat-60.dll&quot;</span>
};
</pre></div>
<p>The function we want to call is in avformat-60.dll, all the others are dependencies that avformat-60.dll
needs.  </p>
<p>If we just try loading avcodec-60.dll first, we get log messages like this:</p>
<pre><code>LogWindows: Failed to load 'd:\tools\ffmpeg6\installed\bin\avcodec-60.dll' (GetLastError=126)
LogWindows:   Missing import: swresample-4.dll
LogWindows:   Missing import: avutil-58.dll
LogWindows:   Missing import: libx264-164.dll
</code></pre>
<p>telling us we need to load those dependencies first.</p>
<h2 id="building-a-plugin-from-the-command-line">Building a plugin from the command line</h2>
<p>To speed up iteration you can package a plugin from the command line like this:</p>
<blockquote>
<p>&quot;C:/Program Files/Epic Games/UE_5.1/Engine/Build/BatchFiles/RunUAT.bat&quot; BuildPlugin -Plugin=&quot;D:/work/learn/PluginsGenerated/Plugins/GeneratedExample/GeneratedExample.uplugin&quot; -Package=&quot;D:/tmp/packaged/GeneratedExample/GeneratedExample&quot; -CreateSubFolder&quot; -nocompile -nocompileuat</p>
</blockquote>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>If a method is called inside a DLL which is delay loaded and that DLL has not been loaded
you get an exception like this:</p>
<p><img src="/images/plugin_006.png" alt="" /></p>
<p>Looking at the call stack we can see the problem is in the delayLoadHelper2 code. </p>
<p><img src="/images/plugin_005.png" alt="" /></p>
<p>To see which DLL is causing the problem look at the local variables:</p>
<p><img src="/images/plugin_005.png" alt="" /></p>
<p>From this we can see the dli-&gt;szDLL variable has the value &quot;avformat-60.dll&quot; so this is 
the DLL which has not been loaded yet.</p>
<h2 id="other-plugin-features">Other plugin features</h2>
<h4 id="include-paths">Include Paths</h4>
<p>If your plugin has include files you can add the directory which contains them to
the include path in the .Build.cs like this:</p>
<div class="csharp"><pre>
<span class="keyword">string</span> IncPath = Path.Combine(ModuleDirectory, <span class="string">&quot;include&quot;</span>);
PublicSystemIncludePaths.Add(IncPath);
</pre></div><h4 id="alternative-names-for-debug-files">Alternative names for debug files</h4>
<p>It is not uncommon to have different file names for release and debug builds, for example
to have the character 'd' appended to the debug file names.  In the .Build.cs file
you can do something like this:</p>
<div class="csharp"><pre>
<span class="keyword">string</span> LibName = <span class="string">&quot;awesomename&quot;</span>;
<span class="keyword">if</span> (Target.Configuration == UnrealTargetConfiguration.Debug
	 &amp;&amp; Target.bDebugBuildsActuallyUseDebugCRT)
{
	LibName += <span class="string">&quot;d&quot;</span>;
}
PublicAdditionalLibraries.Add(Path.Combine(LibPath, LibName + <span class="string">&quot;.lib&quot;</span>));
</pre></div><h4 id="defining-variables">Defining variables</h4>
<p>In the .Build.cs you can define variables which can the be used inside your C++ code:</p>
<div class="csharp"><pre>
PublicDefinitions.Add(<span class="string">&quot;WITH_EXTRA_STUFF=1&quot;</span>);
</pre></div><h2 id="references">References</h2>
<p><a href="https://docs.unrealengine.com/5.1/en-US/integrating-third-party-libraries-into-unreal-engine/">Epic Integrating third-party libraries into Unreal Engine</a></p>

</div>
<footer class="no-sidebar">
<div>
<p class="page-footer">
MIT Licensed | Copyright © 2020-2024 John Farrow
: john.farrow@unrealcode.net
</p>
</div>
</footer>
</main>
</div>
</body>
</html>
