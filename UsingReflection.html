<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Using Reflection in Unreal Engine | unrealcode.net</title>
<meta name="description" content="Using Reflection in Unreal Engine">
<meta charset="utf-8">
<link rel="stylesheet" href="./css/styles.css">
<link rel="stylesheet" href="./css/syntaxhighlightingstyles.css">
</head>
<body>
<div id="app" data-server-rendered="true">
<div class="theme-container">
</div>
<header class="navbar">
<div class="sidebar-button">
</div>
<a href="index.html" aria-current="page" class="home-link router-link-exact-active router-link-active">
<span class="site-name">
unrealcode.net
</span>
</a>
<div class="links">
<nav class="nav-links can-hide">
<div class="nav-item">
<a href="index.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
Home
</a>
</div>
</nav>
</div>
</header>
<div class="sidebar-mask">
</div>
<aside class="sidebar">
<ul class="sidebar-links">
<li>
<section class="sidebar-group depth-0">
<p class="sidebar-heading open">
<span>
Using Reflection in Unreal Engine
</span>
</p>
<ul class="sidebar-links sidebar-group-items">
<li>
<a class="sidebar-link" href="#background">
Background
</a>
</li>
<li>
<a class="sidebar-link" href="#creating-reflection-data">
Creating Reflection Data 
</a>
</li>
<li>
<a class="sidebar-link" href="#accessing-reflection-data">
Accessing Reflection Data
</a>
<ul class="sidebar-sub-headers">
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#class-information">
 Class Information
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#uclass">
UClass 
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#properties">
Properties
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#reading-property-values">
Reading Property Values
</a>
</li>
<li class="sidebar-sub-header">
<a class="sidebar-link" href="#writing-property-values">
Writing Property Values
</a>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</aside>
<main class="page">
<div class="theme-default-content content__default">
<h1>Using Reflection in Unreal Engine</h1>
<p>Updated for Unreal Engine 5.0</p>
<p>Reflection is the ability to inspect C++ classes and objects at runtime and gather information about 
their data types and properties. Normally C++
does not maintain programmer-accessible information about, say, what members a struct or
class has.  Unreal Engine uses macros such as UCLASS and UPROPERTY to create information
about classes, structs, methods, properties, and to make
that information available to C++ at runtime.</p>
<p>This enables a program to introspect an object and find out, for example, what properties
that object has, what the types of those properties are, and given an instance of that object,
what the values of those properties are.  </p>
<h2 id="background">Background</h2>
<p>The notes here were made in the course of 
creating a plugin which checks a project configuration
against a known-good collection of configuration settings, for 
example to check that all the settings required for hardware 
raytracing have their correct values, and have to options to display and change
the current settings, as shown here:</p>
<p><img src="/images/reflection_1.png" alt="" /></p>
<p>This plugin needs to:</p>
<ul>
<li> identify Unreal Engine classes which are used for project settings</li>
<li> identify properties on those classes</li>
<li> retrieve the current values of those properties</li>
<li> change the current values of those properties </li>
</ul>
<p>The classes which Unreal Engine uses for project settings cannot be hard-coded
because they depend on which plugins the user has loaded; so reflection
is a good way of retrieving the required information.</p>
<h2 id="creating-reflection-data">Creating Reflection Data </h2>
<p>Unreal Engine uses macros which are embedded in the c++ class declarations to 
create reflection data.</p>
<p>A class defined using the UCLASS macro like the one below will have reflection data:</p>
<div class="cplusplus"><pre>
UCLASS(config=Engine, defaultconfig)
<span class="keyword">class</span> UWindowsTargetSettings 
	: <span class="keyword">public</span> UObject
{
    ...
}
</pre></div>
<p>The UCLASS macro has many parameters which control how Unreal Engine treats the class, for
example whether it can be accessed using Blueprints.  The parameters are defined 
in <a href="https://docs.unrealengine.com/5.0/en-US/gameplay-classes-in-unreal-engine/">https://docs.unrealengine.com</a>.  At
runtime these parameters can be retrieved from using a c++ API.</p>
<p>Other c++ objects such as enum declarations, functions and properties have corresponding
macros (namely UENUM, UFUNCTION and UPROPERTY) which are used in a similar way
as the UCLASS macro.</p>
<h2 id="accessing-reflection-data">Accessing Reflection Data</h2>
<h3 id="class-information"> Class Information</h3>
<p>The entry point for reflection data is using iterators. To iterate
over the reflection data for all classes which are derived from UObject 
you use this:</p>
<div class="cplusplus"><pre>
<span class="keyword">for</span> (FThreadSafeObjectIterator Itr(UObject::StaticClass()); Itr; ++Itr)
{
	UClass* Class = Itr-&gt;GetClass();
    ...
}
</pre></div>
<p>To limit the search to classes which are derived from a 
base class such as UDeveloperSettings you do this:</p>
<div class="cplusplus"><pre>
<span class="keyword">for</span> (FThreadSafeObjectIterator Itr(UDeveloperSettings::StaticClass()); Itr; ++Itr)
{
	UClass* Class = Itr-&gt;GetClass();
    ...
}
</pre></div><h4 id="uclass">UClass </h4>
<p>Having obtained a UClass* using an  iterator as described above, you can do various useful
things including:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">check if the class is a blueprint or a c++ class</td>
<td style="text-align: left;">Class-&gt;IsNative()</td>
</tr>
<tr>
<td style="text-align: left;">retrieve the class name</td>
<td style="text-align: left;">Class-&gt;GetName(ClassName)</td>
</tr>
<tr>
<td style="text-align: left;">retrieve the config file where class settings are saved</td>
<td style="text-align: left;">Class-&gt;ClassConfigName</td>
</tr>
<tr>
<td style="text-align: left;">retrieve metadata such as the label on the UI settings screen</td>
<td style="text-align: left;">Class-&gt;GetMetaDataText(&quot;DisplayName&quot;)</td>
</tr>
</tbody>
</table>
<h4 id="properties">Properties</h4>
<p>From a UClass* you can retrieve information about the properties, also using a iterator like so:</p>
<div class="cplusplus"><pre>
<span class="keyword">for</span> (TFieldIterator&lt;FProperty&gt; PropIt(Class); PropIt; ++PropIt)
{
	FProperty* Property = *PropIt;
    ...
}
</pre></div>
<p>Similar to dealing with a property, you can call various functions on a property:
|Action|Function|
|:---|:---|
|retrieve the property name|Property-&gt;GetName()|
|retrieve metadata such as the label on the UI settings screen|Property-&gt;GetMetaDataText(&quot;DisplayName&quot;)|</p>
<p>You can retrieve elements of the UPROPERTY declaration. For example given this property 
declaration:</p>
<div class="cplusplus"><pre>
UPROPERTY(config, EditAnywhere, Category = Shadows, meta = (
    ConsoleVariable = <span class="string">&quot;r.Shadow.Virtual.Enable&quot;</span>, 
    DisplayName = <span class="string">&quot;Shadow Map Method&quot;</span>,
    ToolTip = <span class="string">&quot;Select the primary shadow mapping method.&quot;</span>))
    TEnumAsByte&lt;EShadowMapMethod::Type&gt; ShadowMapMethod;
</pre></div>
<p>you can test if the property is a config property declared with UPROPERTY(config) like this:</p>
<div class="cplusplus"><pre>
EPropertyFlags Flags = Property-&gt;PropertyFlags;
<span class="keyword">if</span> ((Flags &amp; EPropertyFlags::CPF_Config) != 0)
</pre></div>
<p>and retrieve variables from the metadata like this:</p>
<pre><code>const FText DisplayName = Property-&gt;GetMetaDataText(&quot;DisplayName&quot;);
const FText ConsoleVariable = Property-&gt;GetMetaDataText(&quot;ConsoleVariable&quot;);
</code></pre>
<p>The type of a property can be retrieved by either:</p>
<ul>
<li> calling <code>Property-&gt;GetCPPType()</code> to return the type as a string, or</li>
<li> testing it by casting like so:</li>
</ul>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (<span class="keyword">const</span> FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
    ...
}
</pre></div>
<p>Looking at the Unreal Engine source code casting seems to be the preferred way.</p>
<h3 id="reading-property-values">Reading Property Values</h3>
<p>The code examples above deal with the static reflection data for properties and classes.  They
do not need a specific instance of a class object to access that data, it is accessed from
static instances such as <code>UDeveloperSettings::StaticClass()</code>.</p>
<p>To extract a property value from an actual instance of a class requires retrieving the
memory address where that property value is stored.  Given an instance of a class
and a property pointer retrieved as shown above, we can do this to find the 
memory address where the property is stored:</p>
<div class="cplusplus"><pre>
FProperty* Property = ...
UClass* Class = ...
<span class="keyword">const</span> uint8* PropertyAddr = Property-&gt;ContainerPtrToValuePtr&lt;uint8&gt;(Class);
</pre></div>
<p>we can then cast the property pointer to its derived property class and retrieve the 
property value using the data address:</p>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (FStrProperty* StringProperty = CastField&lt;FStrProperty&gt;(Property))
{
    Value = StringProperty-&gt;GetPropertyValue(PropertyAddr);
}
</pre></div>
<p>Some types of property require more work, for instance numeric properties can be different
types, as shown here:</p>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (FNumericProperty* NumericProperty = CastField&lt;FNumericProperty&gt;(Property))
{
    <span class="keyword">if</span> (NumericProperty-&gt;IsFloatingPoint())
    {
        Value = FString::SanitizeFloat(NumericProperty-&gt;GetFloatingPointPropertyValue(PropertyAddr));
    }
	<span class="keyword">else</span> <span class="keyword">if</span> (NumericProperty-&gt;IsInteger())
    {
        Value = FString::FromInt(NumericProperty-&gt;GetSignedIntPropertyValue(PropertyAddr));
    }
}
</pre></div>
<p>Enum properties have functions for getting a string representation derived
from the enum value, like so:</p>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
    UEnum* EnumDef = EnumProperty-&gt;GetEnum();
    FNumericProperty* UnderlyingProperty = EnumProperty-&gt;GetUnderlyingProperty();
    int32 IntValue = UnderlyingProperty-&gt;GetSignedIntPropertyValue(PropertyAddr);
    Value = EnumDef-&gt;GetAuthoredNameStringByValue(IntValue);
}
</pre></div>
<p>For an enum declared like this:</p>
<div class="cplusplus"><pre>
<span class="keyword">enum</span> <span class="keyword">class</span> EDefaultGraphicsRHI : uint8
{
    DefaultGraphicsRHI_Default = 0 UMETA(DisplayName = <span class="string">&quot;Default&quot;</span>),
    DefaultGraphicsRHI_DX11 = 1 UMETA(DisplayName = <span class="string">&quot;DirectX 11&quot;</span>),
	DefaultGraphicsRHI_DX12 = 2 UMETA(DisplayName = <span class="string">&quot;DirectX 12&quot;</span>),
	DefaultGraphicsRHI_Vulkan = 3 UMETA(DisplayName = <span class="string">&quot;Vulkan&quot;</span>),
};
</pre></div>
<p>with a property value of <code>EDefaultGraphicsRHI::DefaultGraphicsRHI_DX11</code> the GetSignedIntPropertyValue() call will return 1
and the GetAuthoredNameStringByValue(1) call will return the string &quot;DefaultGraphicsRHI_DX11&quot;.</p>
<h3 id="writing-property-values">Writing Property Values</h3>
<p>The process of writing property values is much the same as reading them, firstly we need to get the address
where the data is stored like so:</p>
<div class="cplusplus"><pre>
FProperty* Property = ...
UClass* Class = ...
<span class="keyword">const</span> uint8* PropertyAddr = Property-&gt;ContainerPtrToValuePtr&lt;uint8&gt;(Class);
</pre></div>
<p>Again we cast the property pointer to see what type it is and 
set the value using the address:</p>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (FNumericProperty* NumericProperty = CastField&lt;FNumericProperty&gt;(Property))
{
    <span class="keyword">if</span> (NumericProperty-&gt;IsFloatingPoint())
	{
		NumericProperty-&gt;SetFloatingPointPropertyValue(PropertyAddr, NewFloatValue);
    }
}
</pre></div>
<p>Each type of property has different methods for setting it.  For example
setting an enum property from a string value involves calling
GetIndexByNameString() to get the int representation of that string:</p>
<div class="cplusplus"><pre>
<span class="keyword">if</span> (FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
	UEnum* EnumDef = EnumProperty-&gt;GetEnum();
	FNumericProperty* UnderlyingNumericProperty = 
       EnumProperty-&gt;GetUnderlyingProperty();

	int64 NewIntValue = EnumDef
       -&gt;GetIndexByNameString(PushedValue, EGetByNameFlags::None);

	<span class="keyword">if</span> (NewIntValue == -1)
	{
        UnderlyingNumericProperty-&gt;SetIntPropertyValue(PropertyAddr, NewIntValue);
    }
}
</pre></div>
</div>
<footer class="no-sidebar">
<div>
<p class="page-footer">
MIT Licensed | Copyright © 2020-2024 John Farrow
: john.farrow@unrealcode.net
</p>
</div>
</footer>
</main>
</div>
</body>
</html>
