<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico><title>Experiments With Chaos Physics - Using C++ - Unreal Engine Development Notes</title><meta name=author content="John Farrow"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="unreal engine,chaos,physics,c++"><meta property="og:title" content="Experiments With Chaos Physics - Using C++"><meta name=twitter:title content="Experiments With Chaos Physics - Using C++"><meta property="og:type" content="article"><meta property="og:url" content="https://johnjfarrow.github.io/posts/physicscpp/"><meta property="og:description" content="Notes on using Chaos Physics and C++ in Unreal Engine"><meta name=twitter:description content="Notes on using Chaos Physics and C++ in Unreal Engine"><meta property="og:image" content="https://johnjfarrow.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://johnjfarrow.github.io/img/og.png"><meta property="article:published_time" content="2022-07-15T10:27:06+12:00"><meta property="article:modified_time" content="2022-07-15T10:27:06+12:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://johnjfarrow.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://johnjfarrow.github.io>Unreal Engine Development Notes</a>
<span class=title-sub>John Farrow</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://johnjfarrow.github.io/posts/physicscpp/>Experiments With Chaos Physics - Using C++</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-07-15</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/unreal-engine>unreal engine</a>&nbsp;<a href=/tags/chaos>chaos</a>&nbsp;<a href=/tags/physics>physics</a>&nbsp;<a href=/tags/c++>c++</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=introduction>Introduction</h2><p>The page <a href=../physicsblueprint>PhysicsUsingBlueprints</a> describes the creation of a simple
physics example implementing a trebuchet using blueprints.</p><p>This page describes implementing the same thing using c++.</p><h2 id=trebuchet-c-class>Trebuchet C++ Class</h2><p>Create the class using the Tools | New C++ Class menu option. Derive the class from the Actor
base class and call it &ldquo;Trebuchet&rdquo;. The editor will automatically prefix the
class name with &ldquo;A&rdquo; so the actual c++ class name will be &ldquo;ATrebuchet&rdquo;.</p><p>Note that this will work even if the project was created as a blueprint project -
adding a c++ class will convert the project to a c++ project.</p><h3 id=atrebuchet-header-file>ATrebuchet Header File</h3><p>This header file looks like this:</p><pre><code class=language-cpp>#pragma once

#include &quot;CoreMinimal.h&quot;
#include &quot;GameFramework/Actor.h&quot;
#include &quot;Trebuchet.generated.h&quot;

class USphereComponent;
class UPhysicsConstraintComponent;

UCLASS()
class PHYSICS_003_API ATrebuchet : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ATrebuchet();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

public:
	UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Arm;
	UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Base;
	UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Ramp;
	UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Weight;
	UPROPERTY(VisibleAnywhere) USphereComponent* Ball;
	UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* ArmBaseConstraint;
	UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* ArmWeightConstraint;
	UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* CableConstraint;

private:
	bool bConstraintBroken = false;
};
</code></pre><p>In addition to the generated code we have added:</p><ul><li>forward declarations for USphereComponent and UPhysicsConstraintComponent classes</li><li>member variables to hold the static mesh components which form the body of the trebuchet</li><li>member variables for the physics constraints</li><li>a member variable to track whether the cable constraint has been broken when the projectile is fired</li></ul><h3 id=atrebuchet-cpp-file>ATrebuchet CPP File</h3><p>The constructor for the ATrebuchet class is shown here:</p><pre><code class=language-cpp>ATrebuchet::ATrebuchet()
{
  PrimaryActorTick.bCanEverTick = true;

  static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; ArmMeshAsset(TEXT(&quot;StaticMesh'/Game/Meshes/SM_Arm.SM_Arm'&quot;));
  static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; BaseMeshAsset(TEXT(&quot;StaticMesh'/Game/Meshes/SM_Base.SM_Base'&quot;));
  static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; RampMeshAsset(TEXT(&quot;StaticMesh'/Game/Meshes/SM_Ramp.SM_Ramp'&quot;));
  static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; WeightMeshAsset(TEXT(&quot;StaticMesh'/Game/Meshes/SM_Weight.SM_Weight'&quot;));

  Base = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Base&quot;));
  Base-&gt;SetStaticMesh(BaseMeshAsset.Object);
  Base-&gt;SetMobility(EComponentMobility::Static);
  Base-&gt;SetCollisionProfileName(TEXT(&quot;BlockAll&quot;));
  RootComponent = Base;

  Ramp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Ramp&quot;));
  Ramp-&gt;SetStaticMesh(RampMeshAsset.Object);
  Ramp-&gt;SetMobility(EComponentMobility::Static);
  Ramp-&gt;SetCollisionProfileName(TEXT(&quot;BlockAll&quot;));
  Ramp-&gt;SetRelativeLocation(FVector( 0.0, 410.0, 40.0 ));
  Ramp-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform );

  Arm = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Arm&quot;));
  Arm-&gt;SetStaticMesh(ArmMeshAsset.Object);
  Arm-&gt;SetMobility(EComponentMobility::Movable);
  Arm-&gt;SetRelativeLocation(FVector( 20.000000,  57.132445,  694.646682));
  Arm-&gt;SetRelativeRotation(FRotator(0.000000, 0.000000, 40.000000));
  Arm-&gt;SetMassOverrideInKg(NAME_None, 505);
  Arm-&gt;SetSimulatePhysics(true);
  Arm-&gt;SetEnableGravity(true);
  Arm-&gt;SetCollisionProfileName(TEXT(&quot;PhysicsActor&quot;));
  Arm-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);

  Weight = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Weight&quot;));
  Weight-&gt;SetStaticMesh(WeightMeshAsset.Object);
  Weight-&gt;SetMobility(EComponentMobility::Movable);
  Weight-&gt;SetRelativeLocation(FVector( 10.000000, -165.000000, 640.000000));
  Weight-&gt;SetSimulatePhysics(true);
  Weight-&gt;SetMassOverrideInKg(NAME_None,4506);
  Weight-&gt;SetEnableGravity(true);
  Weight-&gt;SetCollisionProfileName(TEXT(&quot;PhysicsActor&quot;));
  Weight-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);

  Ball = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;Ball&quot;));
  Ball-&gt;SetMobility(EComponentMobility::Movable);
  Ball-&gt;SetRelativeLocation(FVector(0.000000, 190.000000, 140.000000));
  Ball-&gt;SetSimulatePhysics(true);
  Ball-&gt;SetMassOverrideInKg(NAME_None,15);
  Ball-&gt;SetEnableGravity(true);
  Ball-&gt;SetCollisionProfileName(TEXT(&quot;PhysicsActor&quot;));
  Ball-&gt;SetHiddenInGame(false);
  Ball-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);

  ArmBaseConstraint = CreateDefaultSubobject&lt; UPhysicsConstraintComponent &gt;(TEXT(&quot;ArmBaseConstraint&quot;));
  ArmBaseConstraint-&gt;SetRelativeLocation(FVector(10.000000, 0.000000, 740.000000));
  ArmBaseConstraint-&gt;SetConstrainedComponents( Base, TEXT(&quot;&quot;), Arm, TEXT(&quot;&quot;) );
  ArmBaseConstraint-&gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmBaseConstraint-&gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmBaseConstraint-&gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmBaseConstraint-&gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Locked, 0 );
  ArmBaseConstraint-&gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked, 0 );
  ArmBaseConstraint-&gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free, 0);
  ArmBaseConstraint-&gt;SetDisableCollision(true);
  ArmBaseConstraint-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);

  ArmWeightConstraint = CreateDefaultSubobject&lt; UPhysicsConstraintComponent &gt;(TEXT(&quot;ArmWeightConstraint&quot;));;
  ArmWeightConstraint-&gt;SetRelativeLocation(FVector( 15.000000, -168.000000, 883.000000));
  ArmWeightConstraint-&gt;SetConstrainedComponents(Arm, TEXT(&quot;&quot;), Weight, TEXT(&quot;&quot;));
  ArmWeightConstraint-&gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmWeightConstraint-&gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmWeightConstraint-&gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0);
  ArmWeightConstraint-&gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Locked,0);
  ArmWeightConstraint-&gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked,0);
  ArmWeightConstraint-&gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free,0);
  ArmWeightConstraint-&gt;SetDisableCollision(true);
  ArmWeightConstraint-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);

  CableConstraint = CreateDefaultSubobject&lt; UPhysicsConstraintComponent &gt;(TEXT(&quot;CableConstraint&quot;));;
  CableConstraint-&gt;SetRelativeLocation(FVector( 14.000000, 634.000000, 210.000000));
  CableConstraint-&gt;SetConstrainedComponents(Arm, TEXT(&quot;&quot;), Ball, TEXT(&quot;&quot;));
  CableConstraint-&gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0);
  CableConstraint-&gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0);
  CableConstraint-&gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0);
  CableConstraint-&gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Free,0);
  CableConstraint-&gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Free,0);
  CableConstraint-&gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free,0);
  CableConstraint-&gt;SetDisableCollision(true);
  CableConstraint-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);
}
</code></pre><h4 id=static-mesh-loading>Static Mesh Loading</h4><p>For each static mesh we have an object to locate and load it:</p><pre><code class=language-cpp>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; ArmMeshAsset(TEXT(&quot;StaticMesh'/Game/Meshes/SM_Arm.SM_Arm'&quot;));
</code></pre><p>This works for a simple example, in a larger project you would not do this because:</p><ul><li>it forces the mesh assets to be loaded even if they are not in use</li><li>hard coding the asset path is brittle and hard to maintain</li></ul><p>For most of the static mesh components we set properties like this:</p><pre><code class=language-cpp>Weight = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(&quot;Weight&quot;));
Weight-&gt;SetStaticMesh(WeightMeshAsset.Object);
Weight-&gt;SetMobility(EComponentMobility::Movable);
Weight-&gt;SetRelativeLocation(FVector( 10.000000, -165.000000, 640.000000));
Weight-&gt;SetSimulatePhysics(true);
Weight-&gt;SetMassOverrideInKg(NAME_None,4506);
Weight-&gt;SetEnableGravity(true);
Weight-&gt;SetCollisionProfileName(TEXT(&quot;PhysicsActor&quot;));
Weight-&gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform);
</code></pre><p>The location and rotation values are simply copied from the blueprint project. This is enough to
show physics working from c++.</p><h3 id=properties-and-defaults>Properties and Defaults</h3><p>Note that more properties required setting from c++ than when using the editor. When
using the editor, changing the Mobility property to &ldquo;Movable&rdquo; also changes the
Collision Preset value to &ldquo;PhysicsActor&rdquo;. In c++ we need to manually set both
properties like this:</p><pre><code class=language-cpp>Weight-&gt;SetMobility(EComponentMobility::Movable);
Weight-&gt;SetCollisionProfileName(TEXT(&quot;PhysicsActor&quot;));
</code></pre><p>Also note the defaults for components are different depending on how they are created. A USphere
component has the Hidden In Game property set to false when created in the blueprint editor and
true when created from c++, so we need to explcitly set it in c++:</p><pre><code class=language-cpp>Ball-&gt;SetHiddenInGame(false);
</code></pre><h3 id=cable-release-code>Cable Release Code</h3><p>This image shows the blueprint which breaks the Physics Constraint once the projectile
is travelling in the right direction and at an angle of &lt;= 45 degrees:</p><p><img class=img-zoomable src=/images/chaos_029.png alt></p><p>This is converted into the c++ code shown here:</p><pre><code class=language-cpp>void ATrebuchet::Tick(float DeltaTime)
{
  check(Ball);
  check(CableConstraint);

  Super::Tick(DeltaTime);

  if (!bConstraintBroken )
  {
    const FVector Velocity = Ball-&gt;GetComponentVelocity();

    // assume we firing down X axis, 
    if (Velocity.X &gt; 0)
    {
      const float TrajectoryDegress = 
         FMath::RadiansToDegrees( FMath::Atan(Velocity.Z / Velocity.X) );
      if (TrajectoryDegress &lt; 45)
      {
        CableConstraint-&gt;BreakConstraint();
        bConstraintBroken = true;
      }
    }
  }
}
</code></pre></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/blender/>blender</a></span>
<span><a href=/tags/blueprint/>blueprint</a></span>
<span><a href=/tags/blueprints/>blueprints</a></span>
<span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/chaos/>chaos</a></span>
<span><a href=/tags/ffmpeg/>ffmpeg</a></span>
<span><a href=/tags/gif/>gif</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/physics/>physics</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/rotation/>rotation</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#trebuchet-c-class>Trebuchet C++ Class</a><ul><li><a href=#atrebuchet-header-file>ATrebuchet Header File</a></li><li><a href=#atrebuchet-cpp-file>ATrebuchet CPP File</a></li><li><a href=#properties-and-defaults>Properties and Defaults</a></li><li><a href=#cable-release-code>Cable Release Code</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/blender/>blender</a></span>
<span><a href=/tags/blueprint/>blueprint</a></span>
<span><a href=/tags/blueprints/>blueprints</a></span>
<span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/chaos/>chaos</a></span>
<span><a href=/tags/ffmpeg/>ffmpeg</a></span>
<span><a href=/tags/gif/>gif</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/physics/>physics</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/rotation/>rotation</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#trebuchet-c-class>Trebuchet C++ Class</a><ul><li><a href=#atrebuchet-header-file>ATrebuchet Header File</a></li><li><a href=#atrebuchet-cpp-file>ATrebuchet CPP File</a></li><li><a href=#properties-and-defaults>Properties and Defaults</a></li><li><a href=#cable-release-code>Cable Release Code</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2022
<a href=https://johnjfarrow.github.io>John Farrow</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>