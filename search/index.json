[{"content":"This document is a decription of the basics of reading and writing Json with Unreal Engine classes. This reads and writes elements explictly rather than reading and writing entire structs at one time. This is suitable for objects which are not using the UCLASS or UOBJECT macros to create reflection data.\nNecessary Includes Include these header files:\n#include \u0026quot;Serialization/JsonTypes.h\u0026quot; #include \u0026quot;Serialization/JsonWriter.h\u0026quot; #include \u0026quot;Serialization/JsonSerializer.h\u0026quot; Using constant field names To avoid spelling mistakes and make it easier to change Json field names, I suggest making the field names constants like so:\nnamespace JConstants { const char* const ArrayValue(\u0026quot;array-value\u0026quot;); const char* const ArrayValueDisplayName(\u0026quot;array-value-display-name\u0026quot;); const char* const ArrayValues(\u0026quot;array-values\u0026quot;); const char* const AvailableClasses(\u0026quot;available-classes\u0026quot;); const char* const ClassConfigName(\u0026quot;class-config-name\u0026quot;); const char* const ClassName(\u0026quot;class-name\u0026quot;); const char* const ClassDisplayName(\u0026quot;class-display-name\u0026quot;); const char* const ConsoleVariable(\u0026quot;console-variable\u0026quot;); ... } It is a bit more work up front but it reduces errors.\nWriting Json To create Json make a Json object which will contain everything:\nTSharedRef\u0026lt; FJsonObject \u0026gt; JsonClassObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); Then you can add fields to it using SetXXX methods like so:\nJsonClassObject-\u0026gt;SetStringField( JConstants::ClassName, ClassName); JsonClassObject-\u0026gt;SetBoolField( JConstants::RestartRequired, bRestartRequired); If you need to add a list of child objects, create an array object to hold this list:\nTArray \u0026lt; TSharedPtr\u0026lt;FJsonValue\u0026gt; \u0026gt; JsonPropertyList; Then create each child object and add it to the list object, then finally add the list object to the containing object like so:\nfor( int i = 0; i \u0026lt; 10; ++i ) { // make new child object TSharedRef\u0026lt; FJsonObject \u0026gt; ChildObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); // populate the child object ChildObject-\u0026gt;SetStringField( JConstants::ClassConfigName, ClassConfigName ); ChildObject-\u0026gt;SetStringField( JConstants::ClassDisplayName, ClassDisplayName ); // add the child object to the collection JsonPropertyList.Add(MakeShared\u0026lt;FJsonValueObject\u0026gt;(ChildObject)); } // add the collection to the outer object which contains it JsonClassObject-\u0026gt;SetArrayField(JConstants::Properties, JsonPropertyList); Writing Json to a file First you need to write the Json object to a string, then serialize that string to file like this:\nFString OutputString; TSharedRef\u0026lt;TJsonWriter\u0026lt;\u0026gt;\u0026gt; Writer = TJsonWriterFactory\u0026lt;\u0026gt;::Create(\u0026amp;OutputString); FJsonSerializer::Serialize(JsonOuter, Writer); FFileHelper::SaveStringToFile(OutputString, *AvailableClassesFileName ); Writer-\u0026gt;Close(); Reading Json from a file The entire Json is read from the file into a string, then that string is parsed using the TJsonReader class, then each field and child object can be extracted.\nReading from a file into string is like so:\nconst FString FileName = ResourceDirectory + \u0026quot;\\\\Index.json\u0026quot;; FString Contents; if (FFileHelper::LoadFileToString(Contents, *FileName)) { ... } Parsing the string into Json uses a TJsonReader and a static call on the FJsonSerializer class:\nTSharedPtr\u0026lt;FJsonObject\u0026gt; FullJsonObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); TSharedRef\u0026lt;TJsonReader\u0026lt;\u0026gt;\u0026gt; Reader = TJsonReaderFactory\u0026lt;\u0026gt;::Create(Contents); if( FJsonSerializer::Deserialize(Reader, FullJsonObject) ) { ... } Extracting fields from the reader The most basic approach is to test for the existence of a field and, if it exists, read it from the Json like so:\nif (JsonObject-\u0026gt;HasTypedField\u0026lt;EJson::String\u0026gt;(JConstants::Title)) { JsonObject-\u0026gt;GetStringField(PropertyName); } With some templates shown below this can be simplified to one call per field:\nDescription = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Description ); Source = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Source); SourceURL = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::SourceURL ); Version = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Version); The GetIfExists() function uses templates which are specialized for each data type (to save space only the FString and bool specializations are shown below). First the struct JsonEnum\u0026lt;T\u0026gt; maps from a c++ data type such as FString to the corresponding EJson enumeration EJson::String.\ntemplate\u0026lt; typename T \u0026gt; struct JsonEnum; template \u0026lt;\u0026gt; struct JsonEnum\u0026lt;FString\u0026gt; { const static EJson Type = EJson::String; }; template \u0026lt;\u0026gt; struct JsonEnum\u0026lt;bool\u0026gt; { const static EJson Type = EJson::Boolean; }; Then the struct Extractor\u0026lt;T\u0026gt; maps from a c++ data type such as FString to the corresponding GetXXX() call on the FJsonObject like this:\ntemplate\u0026lt; typename T \u0026gt; struct Extractor; template \u0026lt;\u0026gt; struct Extractor\u0026lt;FString\u0026gt; { FString operator()(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { return JsonObject-\u0026gt;GetStringField(PropertyName); } }; template \u0026lt;\u0026gt; struct Extractor\u0026lt;bool\u0026gt; { bool operator()(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { return JsonObject-\u0026gt;GetBoolField(PropertyName); } }; And finally the GetIfExists() function uses the two above templates:\ntemplate\u0026lt; typename T \u0026gt; T GetIfExists(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { if (JsonObject \u0026amp;\u0026amp; JsonObject-\u0026gt;HasTypedField\u0026lt; JsonEnum\u0026lt;T\u0026gt;::Type \u0026gt;(PropertyName)) { return Extractor\u0026lt;T\u0026gt;{}(JsonObject, PropertyName); } return T(); } Reading arrays of child objects When the Json object has a child array of other objects, this can be accessed using the GetArrayField method:\nif (JsonObject-\u0026gt;HasTypedField\u0026lt;EJson::Array\u0026gt;(JConstants::Settings)) { const TArray\u0026lt;TSharedPtr\u0026lt;FJsonValue\u0026gt;\u0026gt;\u0026amp; Settings = JsonObject-\u0026gt;GetArrayField(JConstants::Settings); for ( const TSharedPtr\u0026lt;FJsonValue\u0026gt;\u0026amp; Setting : Settings) { const TSharedPtr\u0026lt;FJsonObject\u0026gt; Object = Setting-\u0026gt;AsObject(); if (Object) { TSharedRef\u0026lt;FPresetSetting\u0026gt; PresetSetting = MakeShared\u0026lt;FPresetSetting\u0026gt;(); PresetSetting-\u0026gt;ClassConfigName = GetIfExists\u0026lt;FString\u0026gt;( Object, JConstants::ClassConfig); PresetSetting-\u0026gt;ClassDisplayName = GetIfExists\u0026lt;FString\u0026gt;(Object, JConstants::ClassDisplay); PresetSetting-\u0026gt;PropertyDisplayName = GetIfExists\u0026lt;FString\u0026gt;(Object, JConstants::DisplayName); ... } } } ","date":"2022-06-24","permalink":"https://johnjfarrow.github.io/posts/basicsofjson/","tags":["unreal engine","json","c++"],"title":"Using the Unreal Engine Json classes"},{"content":"Reflection Reflection is the ability to inspect c++ classes and objects at runtime and gather information about their data types and properties. Normally C++ does not maintain programmer-accessible information about, say, what members a struct or class has. Unreal Engine uses macros such as UCLASS and UPROPERTY to create information about classes, structs, methods, properties, and to make that information available to C++ at runtime.\nThis enables a programmer to introspect an object and find out, for example, what properties that object has, what the types of those properties are, and given an instance of that object, what the values of those properties are.\nIntentions The notes here were made in the course of creating a plugin which could check a project configuration against a known-good collection of configuration settings, for example to check that all the settings required for hardware raytracing have their correct values, and have to options to display and change the current settings, as shown here:\nThis plugin needed to:\nidentify Unreal Engine classes which were used for project settings identify properties on those classes retrieve the current values of those properties change the current values of those properties The classes which Unreal Engine uses for project settings cannot be hard-coded because they depend on which plugins the user has loaded; so reflection seems like a good way of retrieving the required information.\nCreating Reflection Data Unreal Engine uses macros which are embedded in the c++ class declarations to create reflection data.\nA class defined using the UCLASS macro like the one below will have reflection data:\nUCLASS(config=Engine, defaultconfig) class UWindowsTargetSettings : public UObject { ... } The UCLASS macro has many parameters which control how Unreal Engine treats the class, for example whether it can be accessed using Blueprints. The parameters are defined in https://docs.unrealengine.com. At runtime these parameters can be retrieved from using a c++ API.\nOther c++ objects such as enum declarations, functions and properties have corresponding macros; specifically UENUM, UFUNCTION and UPROPERTY, which behave in the same way as the UCLASS macro.\nAccessing Reflection Data Class Information The entry point for reflection data is using iterators. To iterate over the reflection data for all classes which are derived from UObject you use this:\nfor (FThreadSafeObjectIterator Itr(UObject::StaticClass()); Itr; ++Itr) { UClass* Class = Itr-\u0026gt;GetClass(); ... } To limit the search to classes which derived from a base class such as UDeveloperSettings you do this:\nfor (FThreadSafeObjectIterator Itr(UDeveloperSettings::StaticClass()); Itr; ++Itr) { UClass* Class = Itr-\u0026gt;GetClass(); ... } UClass Having obtained a UClass* using an iterator as described above, you can do various useful things including:\nAction Function check if the class is a blueprint or a c++ class Class-\u0026gt;IsNative() retrieve the class name Class-\u0026gt;GetName(ClassName) retrieve the config file where class settings are saved Class-\u0026gt;ClassConfigName retrieve metadata such as the label on the UI settings screen Class-\u0026gt;GetMetaDataText(\u0026ldquo;DisplayName\u0026rdquo;) Properties From a UClass* you can retrieve information about the properties, also using a iterator like so:\nfor (TFieldIterator\u0026lt;FProperty\u0026gt; PropIt(Class); PropIt; ++PropIt) { FProperty* Property = *PropIt; ... } Similar to dealing with a property, you can call various functions on a property:\nAction Function retrieve the property name Property-\u0026gt;GetName() retrieve metadata such as the label on the UI settings screen Property-\u0026gt;GetMetaDataText(\u0026ldquo;DisplayName\u0026rdquo;) You can retrieve elements of the UPROPERTY declaration. For example given this property declaration:\nUPROPERTY(config, EditAnywhere, Category = Shadows, meta = ( ConsoleVariable = \u0026quot;r.Shadow.Virtual.Enable\u0026quot;, DisplayName = \u0026quot;Shadow Map Method\u0026quot;, ToolTip = \u0026quot;Select the primary shadow mapping method.\u0026quot;)) TEnumAsByte\u0026lt;EShadowMapMethod::Type\u0026gt; ShadowMapMethod; you can test if the property is a config property declared with UPROPERTY(config) like this:\nEPropertyFlags Flags = Property-\u0026gt;PropertyFlags; if ((Flags \u0026amp; EPropertyFlags::CPF_Config) != 0) and retrieve variables from the metadata like this:\nconst FText DisplayName = Property-\u0026gt;GetMetaDataText(\u0026quot;DisplayName\u0026quot;); const FText ConsoleVariable = Property-\u0026gt;GetMetaDataText(\u0026quot;ConsoleVariable\u0026quot;); The type of a property can be retrieved by either:\ncalling Property-\u0026gt;GetCPPType() to return the type as a string, or testing it by casting like so: if (const FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { ... } Looking at the Unreal Engine source code casting seems to be the preferred way.\nReading Property Values The code examples above deal with the static reflection data for properties and classes. They do not need a specific instance of a class object to access that data, it is accessed from static instances such as UDeveloperSettings::StaticClass().\nTo extract a property value from an actual instance of a class requires retrieving the memory address where that property value is stored. Given an instance of a class and a property pointer retrieved as shown above, we can do this to find the memory address where the property is stored:\nFProperty* Property = ... UClass* Class = ... const uint8* PropertyAddr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;uint8\u0026gt;(Class); we can then cast the property pointer to its derived property class and retrieve the property value using the data address:\nif (FStrProperty* StringProperty = CastField\u0026lt;FStrProperty\u0026gt;(Property)) { Value = StringProperty-\u0026gt;GetPropertyValue(PropertyAddr); } Some types of property require more work, for instance numeric properties can be different types, as shown here:\nif (FNumericProperty* NumericProperty = CastField\u0026lt;FNumericProperty\u0026gt;(Property)) { if (NumericProperty-\u0026gt;IsFloatingPoint()) { Value = FString::SanitizeFloat(NumericProperty-\u0026gt;GetFloatingPointPropertyValue(PropertyAddr)); } else if (NumericProperty-\u0026gt;IsInteger()) { Value = FString::FromInt(NumericProperty-\u0026gt;GetSignedIntPropertyValue(PropertyAddr)); } } Enum properties have functions for getting a string representation derived from the enum value, like so:\nif (FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { UEnum* EnumDef = EnumProperty-\u0026gt;GetEnum(); FNumericProperty* UnderlyingProperty = EnumProperty-\u0026gt;GetUnderlyingProperty(); int32 IntValue = UnderlyingProperty-\u0026gt;GetSignedIntPropertyValue(PropertyAddr); Value = EnumDef-\u0026gt;GetAuthoredNameStringByValue(IntValue); } For an enum declared like this:\nenum class EDefaultGraphicsRHI : uint8 { DefaultGraphicsRHI_Default = 0 UMETA(DisplayName = \u0026quot;Default\u0026quot;), DefaultGraphicsRHI_DX11 = 1 UMETA(DisplayName = \u0026quot;DirectX 11\u0026quot;), DefaultGraphicsRHI_DX12 = 2 UMETA(DisplayName = \u0026quot;DirectX 12\u0026quot;), DefaultGraphicsRHI_Vulkan = 3 UMETA(DisplayName = \u0026quot;Vulkan\u0026quot;), }; with a property value of EDefaultGraphicsRHI::DefaultGraphicsRHI_DX11 the GetSignedIntPropertyValue() call will return 1 and the GetAuthoredNameStringByValue(1) call will return the string \u0026ldquo;DefaultGraphicsRHI_DX11\u0026rdquo;.\nWriting Property Values The process of writing property values is much the same as reading them, firstly we need to get the address where the data is stored like so:\nFProperty* Property = ... UClass* Class = ... const uint8* PropertyAddr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;uint8\u0026gt;(Class); Again we cast the property pointer to see what type it is and set the value using the address:\nif (FNumericProperty* NumericProperty = CastField\u0026lt;FNumericProperty\u0026gt;(Property)) { if (NumericProperty-\u0026gt;IsFloatingPoint()) { NumericProperty-\u0026gt;SetFloatingPointPropertyValue(PropertyAddr, NewFloatValue); } } Each type of property has different methods for setting it. For example setting an enum property from a string value involves calling GetIndexByNameString() to get the int representation of that string:\nif (FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { UEnum* EnumDef = EnumProperty-\u0026gt;GetEnum(); FNumericProperty* UnderlyingNumericProperty = EnumProperty-\u0026gt;GetUnderlyingProperty(); int64 NewIntValue = EnumDef -\u0026gt;GetIndexByNameString(PushedValue, EGetByNameFlags::None); if (NewIntValue == -1) { UnderlyingNumericProperty-\u0026gt;SetIntPropertyValue(PropertyAddr, NewIntValue); } } ","date":"2022-06-22","permalink":"https://johnjfarrow.github.io/posts/usingreflection/","tags":["unreal engine","reflection","c++"],"title":"Using Reflection in Unreal Engine"},{"content":"This is a brief guide on downloading and building UE5 using git command line tools and Visual Studio 2022\nAccounts Github Account If you don\u0026rsquo;t have a github account, goto github.com and make one\nEpic Games Account If you don\u0026rsquo;t have an Epic Games account, go to epicgames.com/register and create one\nConnecting the Epic Games account to the Github account You need to connect your Epic Games account to you github account so you can get access to Epic\u0026rsquo;s github repositories\nTo do this:\nsign into your Epic Games account at epicgames.com click on your username near the top right corner of the page and select \u0026ldquo;Account\u0026rdquo; from the dropdown menu click on \u0026ldquo;Connections\u0026rdquo; in the list of options on the left side of the page select \u0026ldquo;Accounts\u0026rdquo; from the tab bar with the \u0026ldquo;Apps\u0026rdquo; and \u0026ldquo;Accounts\u0026rdquo; options under the github icon click the \u0026ldquo;Connect\u0026rdquo; button. This will guide you through a series of steps to connect your Epic Games and github accounts Software Installing git If you do not already have the git commandline tools installed, install them from git-scm.com/downloads\nInstalling Visual Studio 2022 If you do not already have Visual Studio 2022 installed, install it from visualstudio.microsoft.com\nInstall at least these options:\nand\nConfiguring Visual Studio 2022 Some useful options you might like to set are:\nDisable Hot Reload In Tools|Options|Debugging|.NET/C++ Hot Reload disable all the Hot Reload options\nSet Solution Configurations dropdown width Change the width of the Solution Configurations dropdown to handle the longer names used by UE:\nright-click on the toolbar shown below, select \u0026ldquo;Customize\u0026rdquo; change to the \u0026ldquo;Commands\u0026rdquo; tab\nselect \u0026ldquo;Toolbar\u0026rdquo; in the top radio button group\nchange the toolbar value from \u0026ldquo;Build\u0026rdquo; to \u0026ldquo;Standard\u0026rdquo; like so:\nin the preview panel select \u0026ldquo;System Configurations\u0026rdquo; click the \u0026ldquo;Modify Selection\u0026rdquo; button change the width to 130 press \u0026ldquo;OK\u0026rdquo; and \u0026ldquo;Close\u0026rdquo; The toolbar will now have changed to Turn on Indexing To make sure indexed searching is enabled, go to Tools \u0026gt; Options \u0026gt; Environment \u0026gt; Preview Features and verify that “Enable indexing for faster find experience” is checked!\nSee devblogs.microsoft.com\nDownloading \u0026amp; Building Downloading the source Make a new directory such as c:\\work, and change into it\nClone the Unreal Engine source repository:\ngit clone https://github.com/EpicGames/UnrealEngine.git UnrealSource where UnrealSource is the name of a new directory to which the source will be downloaded\nInstalling the UnrealVS plugin for Visual Studio UnrealVS is a Visual Studio plugin from Epic. It is included in the If you are using Visual Studio 2022 exit Visual Studio and install this file [UnrealEngineSource]\\Engine\\Extras\\UnrealVS\\VS2022\\UnrealVS.vsix by double clicking it\nChoosing a branch This page github.com/EpicGames/UnrealEngine/branches lists significant branches including:\nrelease - the latest released version of UE ue5-main - most up to date - this is being continuously updated and won\u0026rsquo;t necessarily build or run on any given day Change into the new source directory created by the git clone command.\nRun git checkout [branch-name] for whichever branch you chose to build\nBuilding This is a summary of information from [https://github.com/EpicGames/UnrealEngine/tree/master]\nChange to the directory in which you downloaded the UE source code and run this command to download and install prerequisites required to build UE - it might take a while:\nSetup.bat then run\nGenerateProjectFiles.bat -2022 Opening the Solution The above commands will create UE5.sln in the current directory, open it in Visual Studio and:\nchange the Solution Configuration dropdown to \u0026ldquo;Development Editor\u0026rdquo; change the Solution Platform to \u0026ldquo;Win64\u0026rdquo; right click the UE5 project in the solution explorer and choose \u0026ldquo;Build\u0026rdquo; This will take some time to complete. On a Ryzen 5950x 16 core machine using an M.2 SSD it took 37 minutes.\nRunning Unreal In the solution explorer right-click \u0026ldquo;UE5\u0026rdquo; under the \u0026ldquo;Engine\u0026rdquo; entry at the top and select \u0026ldquo;Set as Startup Project\u0026rdquo;.\nPress F5 to run UE\nEarlier versions These instructions will work for Unreal 4.27 and Visual Studio 2022. Make sure you clone the git repository then checkout the 4.27 branch before you run Setup.bat or GenerateProjectFiles.bat\nThe solution file created will be called UE4.sln not UE5.sln\n","date":"2022-06-21","permalink":"https://johnjfarrow.github.io/posts/buildfromsource/","tags":["unreal engine","build","c++"],"title":"Building Unreal Engine From Source"}]