[{"content":"Introduction This post is about creating a new Blueprint node in c++ to rotate an Actor object around a pivot point.\nThe image below shows a mesh (called SM_Arm) that was imported into Unreal from a FBX file generated in Blender.\nThe gizmo on the left is at the position of a socket. The red, green and blue lines near the middle indicate the origin of the mesh, which is where the origin was in the Blender model.\nWe create a new blueprint actor, add a Static Mesh component, and set the mesh to SM_Arm. If we place this actor in the world, select it in the outliner, and press E to rotate it, the rotation gizmo (which indicates the pivot point around which it will rotate) is positioned on the origin of the SM_Arm mesh:\nManual Rotation If we want to manually rotate around the socket position, we can use ALT-middle-mouse-click to temporarily move the pivot point like so:\nOnce we have applied a rotation the pivot point will return to the original position.\nBlueprint Rotation Header File No existing single blueprint node supports rotating an actor around a specified pivot point, so as an exercise I decided to write one.\nA blueprint node can be implemented as a static function on a c++ class which is derived from the UBlueprintFunctionLibrary class. To create such a node use the Tools | New C++ Class menu option and create a class derived from UBlueprintFunctionLibrary. In this example the new class is called \u0026ldquo;UtilityFunctionLibrary\u0026rdquo;.\nUnreal will create the header and implementation files. The header looks like this:\n#pragma once #include \u0026quot;CoreMinimal.h\u0026quot; #include \u0026quot;Kismet/BlueprintFunctionLibrary.h\u0026quot; #include \u0026quot;UtilityFunctionLibrary.generated.h\u0026quot; UCLASS() class MYPROJECT8_API UUtilityFunctionLibrary : public UBlueprintFunctionLibrary { GENERATED_BODY() }; There are no methods on the new class. We can add one like so:\n#pragma once #include \u0026quot;CoreMinimal.h\u0026quot; #include \u0026quot;Kismet/BlueprintFunctionLibrary.h\u0026quot; #include \u0026quot;UtilityFunctionLibrary.generated.h\u0026quot; UCLASS() class MYPROJECT8_API UUtilityFunctionLibrary : public UBlueprintFunctionLibrary { GENERATED_BODY() UFUNCTION(BlueprintCallable, Category = \u0026quot;Utility\u0026quot;) static void RotateActorAroundPivot( AActor* Actor, const FVector\u0026amp; PivotLocation, const FRotator\u0026amp; DeltaRotation );\t}; The new function RotateActorAroundPivot takes as parameters the actor object we want to rotate, the pivot point we want to rotate it around, and the size of the rotation.\nUFUNCTION Declaration There are a couple of improvements we can make to the declaration of the RotateActorAroundPivot function, which currently looks like this:\nwe can make the Actor parameter default to \u0026ldquo;self\u0026rdquo;, which is the actor which this blueprint is a part of, by adding meta = (DefaultToSelf = \u0026quot;Actor\u0026quot;) to the UFUNCTION declaration we can make the node easier to use by making the parameters optional (so they will be replaced by default values), by making them values, not references. The updated declaration looks this this:\nUFUNCTION(BlueprintCallable, Category = \u0026quot;Utility\u0026quot;, meta = (DefaultToSelf = \u0026quot;Actor\u0026quot;)) static void RotateActorAroundPivot( AActor* Actor, const FVector PivotLocation, const FRotator DeltaRotation); and the node now looks like this:\nImplementation The implementation of the node contains the maths operations needed to rotate the actor around the pivot point:\nvoid UUtilityFunctionLibrary::RotateActorAroundPivot( AActor* Actor, const FVector PivotLocation, const FRotator DeltaRotation) { if (!Actor) return; Actor-\u0026gt;AddActorWorldRotation(DeltaRotation); FVector NewActorLocation = Actor-\u0026gt;GetActorLocation(); NewActorLocation -= PivotLocation; NewActorLocation = FRotationMatrix(DeltaRotation).TransformPosition(NewActorLocation); NewActorLocation += PivotLocation; NewActorLocation -= Actor-\u0026gt;GetActorLocation(); Actor-\u0026gt;AddActorWorldOffset(NewActorLocation); } This code is very substantially based on the code the editor uses to implement manual rotation.\nUsage This blueprint shows an example usage:\nEvery tick it:\nmultiplies the tick duration by a factor (the Rotation Step variable) to calculate a rotation amount finds the location of the named socket on the Static Mesh component of the actor and rotates the actor around the position of that socket. (This does not need sockets to work, the pivot location could come from anywhere.)\nIf the socket name is left blank, so the socket location is (0,0,0), the mesh rotates around its origin like so:\nWhereas if a socket is chosen which is on the narrow end of the arm mesh, the rotation is like this:\n","date":"2022-07-26","permalink":"https://johnjfarrow.github.io/posts/rotation/","tags":["unreal engine","blueprint","c++","rotation"],"title":"Creating a Blueprint Node in C++"},{"content":"Introduction The page PhysicsUsingBlueprints describes the creation of a simple physics example implementing a trebuchet using blueprints.\nThis page describes implementing the same thing using c++.\nTrebuchet C++ Class Create the class using the Tools | New C++ Class menu option. Derive the class from the Actor base class and call it \u0026ldquo;Trebuchet\u0026rdquo;. The editor will automatically prefix the class name with \u0026ldquo;A\u0026rdquo; so the actual c++ class name will be \u0026ldquo;ATrebuchet\u0026rdquo;.\nNote that this will work even if the project was created as a blueprint project - adding a c++ class will convert the project to a c++ project.\nATrebuchet Header File This header file looks like this:\n#pragma once #include \u0026quot;CoreMinimal.h\u0026quot; #include \u0026quot;GameFramework/Actor.h\u0026quot; #include \u0026quot;Trebuchet.generated.h\u0026quot; class USphereComponent; class UPhysicsConstraintComponent; UCLASS() class PHYSICS_003_API ATrebuchet : public AActor { GENERATED_BODY() public:\t// Sets default values for this actor's properties ATrebuchet(); protected: // Called when the game starts or when spawned virtual void BeginPlay() override; public:\t// Called every frame virtual void Tick(float DeltaTime) override; public: UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Arm; UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Base; UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Ramp; UPROPERTY(VisibleAnywhere) UStaticMeshComponent* Weight; UPROPERTY(VisibleAnywhere) USphereComponent* Ball; UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* ArmBaseConstraint; UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* ArmWeightConstraint; UPROPERTY(VisibleAnywhere) UPhysicsConstraintComponent* CableConstraint; private: bool bConstraintBroken = false; }; In addition to the generated code we have added:\nforward declarations for USphereComponent and UPhysicsConstraintComponent classes member variables to hold the static mesh components which form the body of the trebuchet member variables for the physics constraints a member variable to track whether the cable constraint has been broken when the projectile is fired ATrebuchet CPP File The constructor for the ATrebuchet class is shown here:\nATrebuchet::ATrebuchet() { PrimaryActorTick.bCanEverTick = true; static ConstructorHelpers::FObjectFinder\u0026lt;UStaticMesh\u0026gt; ArmMeshAsset(TEXT(\u0026quot;StaticMesh'/Game/Meshes/SM_Arm.SM_Arm'\u0026quot;)); static ConstructorHelpers::FObjectFinder\u0026lt;UStaticMesh\u0026gt; BaseMeshAsset(TEXT(\u0026quot;StaticMesh'/Game/Meshes/SM_Base.SM_Base'\u0026quot;)); static ConstructorHelpers::FObjectFinder\u0026lt;UStaticMesh\u0026gt; RampMeshAsset(TEXT(\u0026quot;StaticMesh'/Game/Meshes/SM_Ramp.SM_Ramp'\u0026quot;)); static ConstructorHelpers::FObjectFinder\u0026lt;UStaticMesh\u0026gt; WeightMeshAsset(TEXT(\u0026quot;StaticMesh'/Game/Meshes/SM_Weight.SM_Weight'\u0026quot;)); Base = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(TEXT(\u0026quot;Base\u0026quot;)); Base-\u0026gt;SetStaticMesh(BaseMeshAsset.Object); Base-\u0026gt;SetMobility(EComponentMobility::Static); Base-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;BlockAll\u0026quot;)); RootComponent = Base; Ramp = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(TEXT(\u0026quot;Ramp\u0026quot;)); Ramp-\u0026gt;SetStaticMesh(RampMeshAsset.Object); Ramp-\u0026gt;SetMobility(EComponentMobility::Static); Ramp-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;BlockAll\u0026quot;)); Ramp-\u0026gt;SetRelativeLocation(FVector( 0.0, 410.0, 40.0 )); Ramp-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform ); Arm = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(TEXT(\u0026quot;Arm\u0026quot;)); Arm-\u0026gt;SetStaticMesh(ArmMeshAsset.Object); Arm-\u0026gt;SetMobility(EComponentMobility::Movable); Arm-\u0026gt;SetRelativeLocation(FVector( 20.000000, 57.132445, 694.646682)); Arm-\u0026gt;SetRelativeRotation(FRotator(0.000000, 0.000000, 40.000000)); Arm-\u0026gt;SetMassOverrideInKg(NAME_None, 505); Arm-\u0026gt;SetSimulatePhysics(true); Arm-\u0026gt;SetEnableGravity(true); Arm-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;PhysicsActor\u0026quot;)); Arm-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); Weight = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(TEXT(\u0026quot;Weight\u0026quot;)); Weight-\u0026gt;SetStaticMesh(WeightMeshAsset.Object); Weight-\u0026gt;SetMobility(EComponentMobility::Movable); Weight-\u0026gt;SetRelativeLocation(FVector( 10.000000, -165.000000, 640.000000)); Weight-\u0026gt;SetSimulatePhysics(true); Weight-\u0026gt;SetMassOverrideInKg(NAME_None,4506); Weight-\u0026gt;SetEnableGravity(true); Weight-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;PhysicsActor\u0026quot;)); Weight-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); Ball = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(TEXT(\u0026quot;Ball\u0026quot;)); Ball-\u0026gt;SetMobility(EComponentMobility::Movable); Ball-\u0026gt;SetRelativeLocation(FVector(0.000000, 190.000000, 140.000000)); Ball-\u0026gt;SetSimulatePhysics(true); Ball-\u0026gt;SetMassOverrideInKg(NAME_None,15); Ball-\u0026gt;SetEnableGravity(true); Ball-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;PhysicsActor\u0026quot;)); Ball-\u0026gt;SetHiddenInGame(false); Ball-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); ArmBaseConstraint = CreateDefaultSubobject\u0026lt; UPhysicsConstraintComponent \u0026gt;(TEXT(\u0026quot;ArmBaseConstraint\u0026quot;)); ArmBaseConstraint-\u0026gt;SetRelativeLocation(FVector(10.000000, 0.000000, 740.000000)); ArmBaseConstraint-\u0026gt;SetConstrainedComponents( Base, TEXT(\u0026quot;\u0026quot;), Arm, TEXT(\u0026quot;\u0026quot;) ); ArmBaseConstraint-\u0026gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmBaseConstraint-\u0026gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmBaseConstraint-\u0026gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmBaseConstraint-\u0026gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Locked, 0 ); ArmBaseConstraint-\u0026gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked, 0 ); ArmBaseConstraint-\u0026gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free, 0); ArmBaseConstraint-\u0026gt;SetDisableCollision(true); ArmBaseConstraint-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); ArmWeightConstraint = CreateDefaultSubobject\u0026lt; UPhysicsConstraintComponent \u0026gt;(TEXT(\u0026quot;ArmWeightConstraint\u0026quot;));; ArmWeightConstraint-\u0026gt;SetRelativeLocation(FVector( 15.000000, -168.000000, 883.000000)); ArmWeightConstraint-\u0026gt;SetConstrainedComponents(Arm, TEXT(\u0026quot;\u0026quot;), Weight, TEXT(\u0026quot;\u0026quot;)); ArmWeightConstraint-\u0026gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmWeightConstraint-\u0026gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmWeightConstraint-\u0026gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0); ArmWeightConstraint-\u0026gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Locked,0); ArmWeightConstraint-\u0026gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Locked,0); ArmWeightConstraint-\u0026gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free,0); ArmWeightConstraint-\u0026gt;SetDisableCollision(true); ArmWeightConstraint-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); CableConstraint = CreateDefaultSubobject\u0026lt; UPhysicsConstraintComponent \u0026gt;(TEXT(\u0026quot;CableConstraint\u0026quot;));; CableConstraint-\u0026gt;SetRelativeLocation(FVector( 14.000000, 634.000000, 210.000000)); CableConstraint-\u0026gt;SetConstrainedComponents(Arm, TEXT(\u0026quot;\u0026quot;), Ball, TEXT(\u0026quot;\u0026quot;)); CableConstraint-\u0026gt;SetLinearXLimit(ELinearConstraintMotion::LCM_Locked, 0); CableConstraint-\u0026gt;SetLinearYLimit(ELinearConstraintMotion::LCM_Locked, 0); CableConstraint-\u0026gt;SetLinearZLimit(ELinearConstraintMotion::LCM_Locked, 0); CableConstraint-\u0026gt;SetAngularSwing1Limit(EAngularConstraintMotion::ACM_Free,0); CableConstraint-\u0026gt;SetAngularSwing2Limit(EAngularConstraintMotion::ACM_Free,0); CableConstraint-\u0026gt;SetAngularTwistLimit(EAngularConstraintMotion::ACM_Free,0); CableConstraint-\u0026gt;SetDisableCollision(true); CableConstraint-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); } Static Mesh Loading For each static mesh we have an object to locate and load it:\nstatic ConstructorHelpers::FObjectFinder\u0026lt;UStaticMesh\u0026gt; ArmMeshAsset(TEXT(\u0026quot;StaticMesh'/Game/Meshes/SM_Arm.SM_Arm'\u0026quot;)); This works for a simple example, in a larger project you would not do this because:\nit forces the mesh assets to be loaded even if they are not in use hard coding the asset path is brittle and hard to maintain For most of the static mesh components we set properties like this:\nWeight = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(TEXT(\u0026quot;Weight\u0026quot;)); Weight-\u0026gt;SetStaticMesh(WeightMeshAsset.Object); Weight-\u0026gt;SetMobility(EComponentMobility::Movable); Weight-\u0026gt;SetRelativeLocation(FVector( 10.000000, -165.000000, 640.000000)); Weight-\u0026gt;SetSimulatePhysics(true); Weight-\u0026gt;SetMassOverrideInKg(NAME_None,4506); Weight-\u0026gt;SetEnableGravity(true); Weight-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;PhysicsActor\u0026quot;)); Weight-\u0026gt;AttachToComponent(Base, FAttachmentTransformRules::KeepRelativeTransform); The location and rotation values are simply copied from the blueprint project. This is enough to show physics working from c++.\nProperties and Defaults Note that more properties required setting from c++ than when using the editor. When using the editor, changing the Mobility property to \u0026ldquo;Movable\u0026rdquo; also changes the Collision Preset value to \u0026ldquo;PhysicsActor\u0026rdquo;. In c++ we need to manually set both properties like this:\nWeight-\u0026gt;SetMobility(EComponentMobility::Movable); Weight-\u0026gt;SetCollisionProfileName(TEXT(\u0026quot;PhysicsActor\u0026quot;)); Also note the defaults for components are different depending on how they are created. A USphere component has the Hidden In Game property set to false when created in the blueprint editor and true when created from c++, so we need to explcitly set it in c++:\nBall-\u0026gt;SetHiddenInGame(false); Cable Release Code This image shows the blueprint which breaks the Physics Constraint once the projectile is travelling in the right direction and at an angle of \u0026lt;= 45 degrees:\nThis is converted into the c++ code shown here:\nvoid ATrebuchet::Tick(float DeltaTime) { check(Ball); check(CableConstraint); Super::Tick(DeltaTime); if (!bConstraintBroken ) { const FVector Velocity = Ball-\u0026gt;GetComponentVelocity(); // assume we firing down X axis, if (Velocity.X \u0026gt; 0) { const float TrajectoryDegress = FMath::RadiansToDegrees( FMath::Atan(Velocity.Z / Velocity.X) ); if (TrajectoryDegress \u0026lt; 45) { CableConstraint-\u0026gt;BreakConstraint(); bConstraintBroken = true; } } } } ","date":"2022-07-15","permalink":"https://johnjfarrow.github.io/posts/physicscpp/","tags":["unreal engine","chaos","physics","c++"],"title":"Experiments With Chaos Physics - Using C++"},{"content":"Introduction This describes some initial steps in using chaos physics in Unreal Engine 5.0.2.\nThe image below shows a working recreation of a medieval trebuchet built at Warwick Castle in England.\nImage is from https://www.youtube.com/channel/UC89LF5ncbTZi9MukrMSN8eQ\nThis article describes the steps I took to create a working trebuchet model in Unreal Engine.\nBlender Model The image below show an unshaded blender model of the trebuchet.\nThis model is constructed of these parts:\nthe base the arm the counterweight the ramp Each of these was exported from Blender in FBX format using these options\nExporting at the Origin Before exporting it, each component was moved to the origin in Blender. This makes it easier to work with the meshes once they are imported into Unreal. It makes the local coordinate system meaningful.\nTaking the arm component as an example, if it is centered on the world origin in Blender and then exported, in Unreal it looks like this:\nIf it is not centered on the world origin in Blender, in Unreal it looks like this:\nThe difference in the position of the arm\u0026rsquo;s origin effects how it easy it is to manipulate once the FBX file has been imported as a mesh and referenced by a Static Mesh component in blueprint. As this image shows, when the arm is positioned at the world origin in Blender, the Unreal transform gizmo (using world coordinates) is centered on the arm origin:\nand when using local coordinates the Unreal transform gizmo is centered on the arm origin and aligned parallel with the arm to make it easy to position and rotate the arm.\nIf the arm is not centered on the world origin in Blender before it is exported, this is what it looks like in Unreal:\nThe Unreal transform gizmo is not positioned on the arm, making it harder to position, and the local and world coordinate systems are the same, making it difficult to rotate without manually changing the pivot point.\nUsing Chaos Physics To get to the position where we can start adding Physics Constraints, perform these steps to import the FBX files exported from Blender and create a blueprint trebuchet object:\nlaunch Unreal Editor create a new project with the Games, Blank, Blueprint options make new folders under the \u0026ldquo;Content\u0026rdquo; folder called \u0026ldquo;Blueprints\u0026rdquo; and \u0026ldquo;Meshes\u0026rdquo; open the Meshes folder and drop in Arm.fbx, Weight.fbx, Ramp.fbx and Base.fbx rename these meshes SM_Arm, SM_Weight, SM_Ramp, and SM_Base respectively in the Blueprints directory create a new blueprint derived from the Actor parent class. Rename this BP_Trebuchet open BP_Trebuchet in the blueprint editor add a Static Mesh component rename this \u0026ldquo;Base\u0026rdquo; set its static mesh property to \u0026ldquo;SM_Base\u0026rdquo; set its mobility property to \u0026ldquo;Static\u0026rdquo;; this will change Collision Presets to BlockAll drag the Base component and drop it on the \u0026ldquo;DefaultSceneRoot\u0026rdquo; to make it the root component add another Static Mesh component rename this \u0026ldquo;Arm\u0026rdquo; set its static mesh property to \u0026ldquo;SM_Arm\u0026rdquo; set Simulate Physics to checked, this will change Collision Presets to PhysicsActor set its mass to 505 kg which is calculated from its volume and the density of ash set Enable Gravity to checked position the arm to intersect the base axle like so: Things fly apart If you press the Simulate button now you will see something like this:\nWhat\u0026rsquo;s happening here is that the base and the arm are colliding; in their start positions they are occupying the same space where the arm intersects the base axle. The chaos physics solver tries to push them apart violently.\nThis can be prevented by adding a Physics Constraint component to BP_Trebuchet.\nPreventing Collisions: Constraints A Physics Constraint can apply linear and angular forces to objects, and constrain the interactions between objects. It can also disable collisions between objects, which is what we want to do, so we:\nadd a Physics Constraint component rename it \u0026ldquo;ArmBaseStopCollision\u0026rdquo; set Component Name 1 to \u0026ldquo;Base\u0026rdquo; set Component Name 2 to \u0026ldquo;Arm\u0026rdquo; under \u0026ldquo;Constraint Behaviour\u0026rdquo; set Disable Collision to checked set all the linear and angular limits to Free so this constraint does not affect the motion of the arm, like this: Now if you press the Simulate button now you will see something like this:\nThis is what we expect, the arm falls because gravity acts on it, and we have disabled collision with the base so the arm falls right through the base. (If you are using Unreal 5.0.2 you might need to close the blueprint editor window and reopen it to reset the simulation)\nPreventing Collisions: Channels Another way of preventing the arm and the base from colliding is to use a custom Object Channel. We can create a custom Object Channel which represents a type of object. We assign this type to the base component, and then configure the arm component not to collide with objects of this type.\nFrom the menu choose Edit | Project Settings and on the left hand side choose Collision, you will see this screen:\nClick the \u0026ldquo;New Object Channel\u0026rdquo; button to create a new channel. On the screen above you can see we have already added a custom channel cells \u0026ldquo;CustomBaseChannel\u0026rdquo;\nEdit the BP_Trebuchet blueprint and select the Base StaticMesh component.\nSet the collision properties like this:\nThis tells Unreal that when resolving collisions the base should be considered to be of type \u0026ldquo;CustomBaseChannel\u0026rdquo;.\nNext select the Arm component and configure the collision properties like this:\nThis tells Unreal that when the arm collides with something of the \u0026ldquo;CustomBaseChannel\u0026rdquo; type, to ignore that collision.\nConstraining the Arm We want the arm to pivot around the axle. If we change all the Linear Limits to Locked, and change Swing 1 Motion and Swing 2 Motion to locked, leaving Twist Motion as Free, the only way the arm can move is to pivot is around the X axis.\nLooking at the tooltip for Twist Limit it sort of explains what Twist Motion does: \u0026ldquo;Symmetric angle of roll along the X-axis\u0026rdquo;. This tells us the Twist Motion properties control the twist around the X-axis of the constraint, not the X-Axis of the constrained components. You can see this by changing the yaw angle (rotation around the local X-axis) of the constraint - at 45 degrees the arm just tips over slightly, at 90 degrees nothing happens at all.\nLooking at the image below, we can see the constraint X-axis (the red one) is pointing parallel to the axle which is what we want.\nIf we press the Simulate button from this position the arm pivots around the position of the constraint like so:\nIf we position the constraint where the axle is like this:\nThen we get the arm swinging in the way we want:\nAdding the Counterweight Add another Static Mesh component\nrename this \u0026ldquo;Weight\u0026rdquo; set its static mesh property to \u0026ldquo;SM_Weight\u0026rdquo; set Simulate Physics to checked, this will change Collision Presets to PhysicsActor set its mass to 4506 kg which is calculated from its volume and the density of stone set Enable Gravity to checked position the weight to intersect the arm like so: Add a Physics Constraint component to link the weight to the arm:\nrename it \u0026ldquo;ArmWeightConstraint\u0026rdquo; set Component Name 1 to \u0026ldquo;Arm\u0026rdquo; set Component Name 2 to \u0026ldquo;Weight\u0026rdquo; under \u0026ldquo;Constraint Behaviour\u0026rdquo; set Disable Collision to checked move the constraint to where the weight is attached to the arm Add another Physics Constraint just to stop the weight colliding with the base:\nrename it \u0026ldquo;BaseWeightConstraint\u0026rdquo; set Component Name 1 to \u0026ldquo;Base\u0026rdquo; set Component Name 2 to \u0026ldquo;Weight\u0026rdquo; under \u0026ldquo;Constraint Behaviour\u0026rdquo; set Disable Collision to checked set all the limits to Free so it does nothing but disable the collision: Preventing Collisions: Meshes Even though we can see that the base and the weight do not collide the BaseWeightConstraint constraint is necessary because the base is using a simple collision volume. Open the SM_Base mesh and click Show | Simple Collision, this shows that the base is using a collision volume which includes the area where the weight swings:\nAn alternative to adding the BaseWeightConstraint constraint is to use the complex collision volume for the base. Click Show | Complex Collision to show the more complex and better fitting collision volume:\nWe can use this by changing the Collision Complexity property of the SM_Mesh to \u0026ldquo;Use Complex Collision as Simple\u0026rdquo; which will make Unreal use the complex collision volume in all cases.\nNow when simulating the weight should pull the arm down like so:\nAdding the Ramp The ramp is a separate mesh which the projectile slides along when it is launched. It is added by:\nadding a new Static Mesh to BP_Trebuchet component rename this \u0026ldquo;Ramp\u0026rdquo; set its static mesh property to \u0026ldquo;SM_Ramp\u0026rdquo; set its mobility property to \u0026ldquo;Static\u0026rdquo;; this will change Collision Presets to BlockAll position it like this: Adding the Projectile The projectile is Sphere component. In theory it could be a separate actor because there can be many projectiles, and when they are thrown the move far away from the trebuchet, but for the purposes of learning chaos physics a component will suffice.\nAdd the projectile by\nadding a new Sphere component to BP_Trebuchet component rename this \u0026ldquo;Ball\u0026rdquo; set Simulate Physics to checked, this will change Collision Presets to PhysicsActor set its mass to 15 kg set Enable Gravity to checked position it on the ramp like this: When the real trebuchet fires the arm is positioned close to the ground as shown in the top picture, so rotate the arm to a similar position like this:\nWe will use a Physics Constraint to represent the connection between the arm and the ball. So:\nadd a Physics Constraint component rename it \u0026ldquo;CableConstraint\u0026rdquo; set Component Name 1 to \u0026ldquo;Arm\u0026rdquo; set Component Name 2 to \u0026ldquo;Ball\u0026rdquo; under \u0026ldquo;Constraint Behaviour\u0026rdquo; set Disable Collision to checked set all the linear limits to Locked and all the angular limits to Free position the constraint at the end of the arm like this: Now pressing Play in the editor should result in this motion:\nReleasing the Projectile The ball swings in the manner we want, but it remains connected to the arm. We need to find a way to break the constraint connecting the ball to the arm. There are several ways to do this, we could for example:\nbreak the constraint when the ball enters a certain area break the constraint when the ball is travelling at a certain angle break the constraint when the ball is travelling at a certain velocity We can visualize the velocity using a blueprint like this:\nAssuming the trebuchet is aligned to fire down the X-axis, when the velocity in the X direction is greater than zero this blueprint will:\ndraw a vector representing the velocity of the ball, so a longer line represents a greater velocity print the angle of the velocity at the end of each vector The output looks like this:\nThis is the last frame:\nIf we arbitrarily decide to fire when the angle is about 45 degrees, we can calculate the angle of the projectile from the velocity, and break the constraint between the arm and the ball as soon as the angle is \u0026lt;= 45 degrees.\nWe update the blueprint by adding a variable to track if the constraint has been broken, and break the constraint the first time the angle is \u0026lt;= 45 degrees:\nAnd we get this result:\nReferences Custom Channels - https://docs.unrealengine.com\n","date":"2022-07-12","permalink":"https://johnjfarrow.github.io/posts/physicsblueprint/","tags":["unreal engine","chaos","physics","blueprints","blender"],"title":"Experiments With Chaos Physics - Using Blueprints"},{"content":"Introduction This describes one approach to making GIF files from Unreal Engine. This approach is used to make the GIF files on this site.\nTools This approach uses Sequencer and ffmpeg. Both Sequencer and ffmpeg have many, many functions and options, here we use the bare minimum required to create a GIF.\nffmpeg can be downloaded from https://ffmpeg.org/download.html\nRecording from Unreal Engine Adding a Master Sequence We will be using a master sequence, which is an object which controls a collection of shots. For the purposes of this exercise we will have only one shot.\nAssuming you are in the Unreal editor, click on the Cinematics button and select \u0026ldquo;Add Master Sequence\u0026rdquo; like this:\nThis dialog appears:\nChange the Number of Shots to 1 and click the \u0026ldquo;Create Master Sequence\u0026rdquo; button.\nAdding the master sequence opens the Sequencer tab like so:\nand adds a CineCameraActor object to the scene, visible in the Outliner window:\nThe lightning bolt next to the actor in the outliner window indicates the camera is spawnable and so only exists in the scene when sequencer is rendering.\nAiming the Camera One way of positioning the camera is to right click it in the outliner and select \u0026ldquo;Pilot CineCameraActor\u0026rdquo; and then change the view to point the camera at scene you want rendered in the GIF:\nOnce the camera is pointed where you want right click the camera again and select \u0026ldquo;Stop Piloting CineCameraActor\u0026rdquo;.\nSetting the GIF Duration If it helps you can change the timeline from frame to seconds by clicking on the \u0026ldquo;30 fps\u0026rdquo; button:\nWe need to do two things to change the length of the shot\n(1) In the sequencer window click the red line and drag it to the left to shorten the length of the camera cut:\n(2) Click the SequenceMaster button shown here:\nand drag the rightmost red line to change the length of the shot:\nRendering to PNG files We want to render each frame to a separate PNG file which will serve as the input to ffmpeg.\nClick the render button shown here:\nChange the render settings to the ones shown here:\nParticularly we changed these values from their defaults:\nImage Output Format to Image Sequence Resolution to 1280 x 720 Filename Format to {world}_{frame}, changing the default \u0026ldquo;.\u0026rdquo; to \u0026ldquo;_\u0026rdquo; Overwrite Existing (In Advanced) to checked, otherwise each time you capture frames the file names will change Delay Before Warm Up to 1.0s, otherwise the first frame can be blurred Press the Capture Movie button. Once capture is complete a notification popup appears and you can press \u0026ldquo;Open Capture Folder\u0026rdquo; to open the directory where the PNG files were generated.\nCreating the GIF using ffmpeg Assuming you have ffmpeg installed and on the path, there are two commands to run to create a GIF from the set of image files created by Unreal.\nThe example Unreal level used here was called \u0026ldquo;MainMap\u0026rdquo; - this provides the basis for the file names created by the Capture Movie process - you will need to substitute your own map name in these commands.\nThese steps are:\nopen a command window change to the directory containing the image files run this command to create a palette from the colours used in the first PNG file. ffmpeg -i MainMap_0001.png -vf palettegen palette.png -y run this command to create the GIF file ffmpeg -framerate 24 -i Mainmap_%4d.png -i palette.png -y -filter_complex \u0026quot;paletteuse[v];[v]scale=720:-1\u0026quot; output.gif The scale value changes the quality of the GIF, higher values mean better quality but a larger GIF file. The framerate specified should match the framerate used in the Render Movie Settings dialog. The GIF below was recorded at 24fps and created by ffmpeg at 12fps so it appears to be in slow motion.\nFor example with \u0026ldquo;scale=720\u0026rdquo; the GIF below is 18.1 Mb:\nWhereas with \u0026ldquo;scale=360\u0026rdquo; it is only GIF below was reduced to 4.5 Mb:\nIf you place these commands into a .bat file, you will need to change the \u0026ldquo;%\u0026rdquo; character to \u0026ldquo;%%\u0026rdquo; like so:\nffmpeg -framerate 24 -i Mainmap_%4d.png -i palette.png -y -filter_complex \u0026quot;paletteuse[v];[v]scale=720:-1\u0026quot; output.gif becomes\nffmpeg -framerate 24 -i Mainmap_%%4d.png -i palette.png -y -filter_complex \u0026quot;paletteuse[v];[v]scale=720:-1\u0026quot; output.gif References Sequencer Tutorial https://www.youtube.com/watch?v=5jHhIah8H7U\nSequencer Bad First Frame https://forums.unrealengine.com\n","date":"2022-07-12","permalink":"https://johnjfarrow.github.io/posts/giffromunreal/","tags":["unreal engine","gif","ffmpeg"],"title":"Making GIF Files with Unreal Engine"},{"content":"Background The notes here were made in the course of creating a plugin which checks a project configuration against a known-good collection of configuration settings, for example to check that all the settings required for hardware raytracing have their correct values, and have to options to display and change the current settings, as shown here:\nOverview Slate is a cross-platform user interface framework for creating tool and in-game UI.\nSlate is used by the default code generated when creating a new plugin.\nWhen creating a new plugin the generated code for the main window of the plugin looks like this:\nclass SPresetBrowser : public SCompoundWidget { SLATE_BEGIN_ARGS(SPresetBrowser) { } SLATE_END_ARGS() virtual ~SPresetBrowser(); /** Widget constructor */ void Construct(const FArguments\u0026amp; Args, const TArray\u0026lt; TSharedRef\u0026lt;FPreset\u0026gt; \u0026gt;\u0026amp; ); }; This shows two key features of Slate:\nThe use of the SLATE_BEGIN_ARGS/SLATE_END_ARGS macros to declare arguments The Construct() method which is where the actual UI objects are created. The code used in the examples below is based on the concept of a \u0026lsquo;preset\u0026rsquo;, which is a group of editor properties like the ones shown in the image above. Each property has fields which identify it such as the screen prompt in the project settings editor, and the target value.\nObject Hierarchy The data objects for this plugin are listed in the table below. The data objects form a hierarchy, and so do the UI widgets representing each data object.\nData Object Details UI Widget FPresetList Holds all of the data objects for the entire plugin SPresetBrowser FPreset Holds all of the data for one preset, including a list of properties and their desired values SPresetTile FPresetSetting Holds the data about one property such as name, type, desired value SPresetSettingTile The data objects have a hierarchy like this:\nFPresetList FPreset FPresetSetting And the corresponding UI widgets have a hierarchy like this:\nSPresetBrowser SPresetTile SPresetSettingTile Each of the UI widgets is a subclass of SCompoundWidget, and each overrides the Construct() method to create its child widgets.\nEach widget which has children has:\na member which is a list of child data objects and a member of type SListView which displays whatever is in the list of child data objects. Specifically:\nthe SPresetBrowser has a list of FPreset objects and an SListView member the SPresetTile has a list of FPresetSetting objects and an SListView member The Construct method The SPresetBrowser Construct method looks like this:\nvoid SPresetBrowser::Construct(const FArguments\u0026amp; Args, const TArray\u0026lt; TSharedRef\u0026lt;FPreset\u0026gt; \u0026gt;\u0026amp; InPresets ) { TSharedRef\u0026lt;SBorder\u0026gt; MainContent = SNew(SBorder) .BorderImage(FAppStyle::Get().GetBrush(\u0026quot;Brushes.Panel\u0026quot;)) .Padding(0.f) [ SNew(SVerticalBox) + SVerticalBox::Slot() .VAlign(VAlign_Top) [ SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this)) ] ]; ChildSlot [ MainContent ]; } This shows the basic idea of constructing a UI declaratively using c++.\nThe SNew macro This creates a widget, as in SNew(SVerticalBox) and makes it available for other calls such as VAlign() as shown above\nThe SAssignNew macro This creates a widget like SNew() does but also assigns it to a member shared pointer so it can be referenced later\nSlots Many widgets have positions for child widgets. The positions are called slots. Slots are created and accessed in different ways:\nSome widgets already have slots when the widget is constructed; like the SPresetBrowser itself which is created with a slot called ChildSlot which can be accessed as shown above. Widgets such as SHorizontalBox and SVerticalBox (as shown above) need to have each slot added using a call to +SHorizontalBox::Slot() or +SVerticalBox::Slot(). some widgets have slots in specific places. The SGridPanel uses +SGridPanel::Slot(ColNum, RowNum) to add a child widget in a specific place in the grid Styles The call to BorderImage() above calls FAppStyle::Get() to access a style object. Style objects contain brushes (a rectangular area of a specific color), images, border detail and more. Style objects enable setting values such as a font size or a widget color in one place (on the style) and reusing it in many places, ensuring a consistent look and feel to the application. Making changes to the look of an application is easier because the styles are all in one place.\nConstruction approaches Widgets can be created and stored in variables, or created inline. The two code samples below do the same thing, the first stores the SVerticalBox widget in a variable and then adds it to the child slot, the second creates it in the child slot directly:\nTSharedRef\u0026lt;SBorder\u0026gt; Variable = SNew(SVerticalBox) + SVerticalBox::Slot() .VAlign(VAlign_Top) [ SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this)) ] ]; ChildSlot [ Variable ]; ChildSlot [ SNew(SVerticalBox) + SVerticalBox::Slot() .VAlign(VAlign_Top) [ SAssignNew(PresetListWidget, SPresetTileList, SharedThis(this)) ] ]; ]; Some widgets automatically create child widgets. The SListView widget is constructed like this:\nPresetListViewWidget = SNew(SListView\u0026lt; TSharedRef\u0026lt;FPreset\u0026gt; \u0026gt;) .SelectionMode(ESelectionMode::Single) .ListItemsSource(\u0026amp;PresetListItems) .OnGenerateRow(this, \u0026amp;SPresetTileList::PresetListView_OnGenerateRow) .ListViewStyle(FAppStyle::Get(), \u0026quot;SimpleListView\u0026quot;); These lines:\n.ListItemsSource(\u0026amp;PresetListItems) .OnGenerateRow(this, \u0026amp;SPresetTileList::PresetListView_OnGenerateRow) pass the SListView a list of FPreset objects, and tell it to call PresetListView_OnGenerateRow() once for every row. The PresetListView_OnGenerateRow() method creates and returns the widget(s) which represent one row:\nTSharedRef\u0026lt;ITableRow\u0026gt; SPresetTileList::PresetListView_OnGenerateRow( TSharedRef\u0026lt;FPreset\u0026gt; Item, const TSharedRef\u0026lt;STableViewBase\u0026gt;\u0026amp; OwnerTable) { return SNew(STableRow\u0026lt; TSharedRef\u0026lt;FPreset\u0026gt; \u0026gt;, OwnerTable) [ SNew(SPresetTile, SharedThis(this), Item) ]; } Buttons Buttons are implemented using the SButton class and styled using the SButtonStyle class. This code shows creation of a button widget:\nconst FText ApplyButtonLabel = LOCTEXT(\u0026quot;WindowWidgetText\u0026quot;, \u0026quot;Apply\u0026quot;); SNew(SButton) .ButtonStyle( FEditorPresetsPluginStyle::Get(), \u0026quot;PresetTile.ApplyButtonStyle\u0026quot; ) .HAlign(HAlign_Center) .VAlign(VAlign_Center) .IsEnabled_Lambda([this]() -\u0026gt; bool { return PresetSetting-\u0026gt;EditorValueIsDifferent() || PresetSetting-\u0026gt;bRevertable; }) .ContentPadding(FMargin(4.0f, 4.0f)) .OnClicked_Raw(this, \u0026amp;SPropertySettingTile::OnApplyButtonClicked) [ SAssignNew(ApplyRevertButtonLabel,STextBlock) .Text(ApplyButtonLabel) .Margin(2.0f) ] This illustrates a number of interesting points:\nButtons are Containers The SButton object draws a rectangle on the screen. Any text on the button comes from child widgets of the button. This part of the above code shows the creation of a text block which contains the text which appears on the button:\n[ SAssignNew(ApplyRevertButtonLabel,STextBlock) .Text(ApplyButtonLabel) .Margin(2.0f) ] Button Styles The style used here is created with the code below when the plugin is initialized. This code sets the color to be used by the button when the button is in various states such as Normal, Hovered Over, and Disabled. The style is added to the StyleInstance object along with other styles and can be retrieved using the \u0026ldquo;PresetTile.ApplyButtonStyle\u0026rdquo; key.\nvoid FEditorPresetsPluginStyle::Initialize() { FColor ButtonColor = FColor::Green; FButtonStyle ApplyButtonStyle = FAppStyle::Get().GetWidgetStyle\u0026lt; FButtonStyle \u0026gt;(\u0026quot;SimpleButton\u0026quot;); ApplyButtonStyle.SetNormal(FSlateColorBrush(ButtonColor)); ApplyButtonStyle.SetHovered(FSlateColorBrush(ButtonColor)); ApplyButtonStyle.SetDisabled(FSlateColorBrush(FSlateColor::UseSubduedForeground())); ApplyButtonStyle.SetNormalForeground(FStyleColors::Black); ApplyButtonStyle.SetHoveredForeground(FStyleColors::Black); StyleInstance-\u0026gt;Set(\u0026quot;PresetTile.ApplyButtonStyle\u0026quot;, ApplyButtonStyle); } To use the style specify the static StyleInstance object for the plugin and key \u0026ldquo;PresetTile.ApplyButtonStyle\u0026rdquo; like so:\nSNew(SButton) .ButtonStyle( FEditorPresetsPluginStyle::Get(), \u0026quot;PresetTile.ApplyButtonStyle\u0026quot; ) Callbacks and Events The lines\nSNew(SButton) .IsEnabled(true) shows the simplest way of specifying a parameter to the IsEnabled method. Other ways exist such as:\nIsEnabled(this, \u0026amp;FMedia::IsAutoDetectEnabled) Takes a pointer to an object and a method to be called on that object. This version calls shared_from_this() on the object parameter to make a shared pointer to the object. It will fail if that object is still being constructed because shared_from_this() cannot be called on a partially constructed object. This method does have the advantage that it uses a shared pointer to keep the referenced object alive.\nIsEnabled_Raw(this, \u0026amp;FMedia::IsAutoDetectEnabled) Takes a pointer to an object and method to be called on that object. This version takes a raw pointer and will not call shared_from_this() so can be called when the object has not finished construction.\nIsEnabled_Lambda Takes a lambda returning a bool, for example:\nSNew(SButton) .IsEnabled_Lambda([this]() -\u0026gt; bool { return PresetSetting-\u0026gt;EditorValueIsDifferent(); }) This means the enabled state of the button can change when the data changes.\nIsEnabled_Static(\u0026amp;FMedia::IsNotCustomEventOverride, FunctionEntryNodePtr) Takes a static function and a parameter\nIsEnabled_UObject(Item, \u0026amp;FMedia::GetOwnerIsEnabled) Takes a pointer to a UObject and a member method\nIsEnabled_UObject(this, \u0026amp;FMedia::IsImportEnabled, ContextObject) Takes a reference to a method and an additional UObject parameter|\nEvents This code shows a callback when a button is clicked:\nSNew(SButton) .OnClicked_Raw(this, \u0026amp;SPropertySettingTile::OnApplyButtonClicked ) Like the Callbacks section above, there are many variations of the OnClicked() method taking different parameters.\nThe implementation of the OnApplyButtonClicked method looks like this:\nFReply SPropertySettingTile::OnApplyButtonClicked() { if (EditorValueWidget.IsValid()) { EditorValueWidget-\u0026gt;SetText(FText::FromString(PresetSetting-\u0026gt;EditorValue)); } return FReply::Handled(); } The only special detail to note is that it returns an FReply object telling the editor whether the click was handled or not.\nBeware of Logic Errors The behaviour of a specific widget sometimes depends on the widget it is contained in. For example this code creates an SListView widget which creates one row for each of the ten entries in the Data collection:\nSNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ SNew(SListView\u0026lt; TSharedRef\u0026lt; DataClass \u0026gt; \u0026gt;) .ListItemsSource(\u0026amp;Data) .SelectionMode(ESelectionMode::None) .OnGenerateRow(this, \u0026amp;SPresetBrowser::OnGenerateRow) .ListViewStyle(FAppStyle::Get(), \u0026quot;SimpleListView\u0026quot;) ] but the list view will display without a scrollbar. This is because there is a conflict between the way the height of the SListView is calculated and the way the height of the containing SVerticalBox is calculated. The SListView needs to know the height of its container so it can calculate its own height and hence the position of the scrollbar, but because .AutoHeight() is specified on the SVerticalBox the height of the vertical box is in turn calculated. It is not possible to satisfy both these requirements.\nWidget Reflector This tool is found in the Unreal Editor under Tools|Debug|Widget Reflector. It shows a windows like this: To use it click the \u0026ldquo;Pick Hit-Testable Widgets\u0026rdquo;, then click on a widget in your UI, then hit escape. The Widget Reflector window will now show the hierarchy of widgets and their children like so: Picking a widget in the hierarchy will highlight it in the UI as shown in the above image by the green box around the selected widget. You can also click on the \u0026ldquo;Source\u0026rdquo; column to jump to the line of code which created that widget.\n","date":"2022-06-25","permalink":"https://johnjfarrow.github.io/posts/slate/","tags":["unreal engine","slate","c++"],"title":"Using Slate UI Classes from C++"},{"content":"This document describes the basics of reading and writing Json with Unreal Engine classes. The code here reads and writes elements explicitly rather than reading and writing entire structs at one time. This is suitable for objects which are not using the UCLASS or UOBJECT macros to create reflection data.\nNecessary Includes Include these header files:\n#include \u0026quot;Serialization/JsonTypes.h\u0026quot; #include \u0026quot;Serialization/JsonWriter.h\u0026quot; #include \u0026quot;Serialization/JsonSerializer.h\u0026quot; Using constant field names To avoid spelling mistakes and make it easier to change Json field names, I suggest making the field names constants like so:\nnamespace JConstants { const char* const ArrayValue(\u0026quot;array-value\u0026quot;); const char* const ArrayValueDisplayName(\u0026quot;array-value-display-name\u0026quot;); const char* const ArrayValues(\u0026quot;array-values\u0026quot;); const char* const AvailableClasses(\u0026quot;available-classes\u0026quot;); const char* const ClassConfigName(\u0026quot;class-config-name\u0026quot;); const char* const ClassName(\u0026quot;class-name\u0026quot;); const char* const ClassDisplayName(\u0026quot;class-display-name\u0026quot;); const char* const ConsoleVariable(\u0026quot;console-variable\u0026quot;); ... } It is a bit more work up front but it reduces errors.\nCreating Json To create Json make a Json object which will contain everything:\nTSharedRef\u0026lt; FJsonObject \u0026gt; JsonClassObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); Then you can add fields to it using SetXXX methods like so:\nJsonClassObject-\u0026gt;SetStringField( JConstants::ClassName, ClassName); JsonClassObject-\u0026gt;SetBoolField( JConstants::RestartRequired, bRestartRequired); If you need to add a list of child objects, create an array object to hold this list:\nTArray \u0026lt; TSharedPtr\u0026lt;FJsonValue\u0026gt; \u0026gt; JsonPropertyList; Then create each child object and add it to the list object, then finally add the list object to the containing object like so:\nTSharedRef\u0026lt; FJsonObject \u0026gt; JsonOuterObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); for( int i = 0; i \u0026lt; 10; ++i ) { // make new child object TSharedRef\u0026lt; FJsonObject \u0026gt; ChildObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); // populate the child object ChildObject-\u0026gt;SetStringField( JConstants::ClassConfigName, ClassConfigName ); ChildObject-\u0026gt;SetStringField( JConstants::ClassDisplayName, ClassDisplayName ); // add the child object to the collection JsonPropertyList.Add(MakeShared\u0026lt;FJsonValueObject\u0026gt;(ChildObject)); } // add the collection to the outer object which contains it JsonOuterObject-\u0026gt;SetArrayField(JConstants::Properties, JsonPropertyList); Writing Json to a file First you need to write the Json object to a string, then serialize that string to file like this:\nFString OutputString; TSharedRef\u0026lt;TJsonWriter\u0026lt;\u0026gt;\u0026gt; Writer = TJsonWriterFactory\u0026lt;\u0026gt;::Create(\u0026amp;OutputString); FJsonSerializer::Serialize(JsonOuter, Writer); FFileHelper::SaveStringToFile(OutputString, *AvailableClassesFileName ); Writer-\u0026gt;Close(); Reading Json from a file The entire Json is read from the file into a string, then that string is parsed using the TJsonReader class, then each field and child object can be extracted.\nReading from a file into string is like so:\nconst FString FileName = ResourceDirectory + \u0026quot;\\\\Index.json\u0026quot;; FString Contents; if (FFileHelper::LoadFileToString(Contents, *FileName)) { ... } Parsing the string into Json uses a TJsonReader and a static call on the FJsonSerializer class:\nTSharedPtr\u0026lt;FJsonObject\u0026gt; FullJsonObject = MakeShared\u0026lt;FJsonObject\u0026gt;(); TSharedRef\u0026lt;TJsonReader\u0026lt;\u0026gt;\u0026gt; Reader = TJsonReaderFactory\u0026lt;\u0026gt;::Create(Contents); if( FJsonSerializer::Deserialize(Reader, FullJsonObject) ) { ... } Extracting fields from the reader The most basic approach is to test for the existence of a field and, if it exists, read it from the Json like so:\nif (JsonObject-\u0026gt;HasTypedField\u0026lt;EJson::String\u0026gt;(JConstants::Title)) { JsonObject-\u0026gt;GetStringField(PropertyName); } With some templates shown below this can be simplified to one call per field:\nDescription = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Description ); Source = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Source); SourceURL = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::SourceURL ); Version = GetIfExists\u0026lt;FString\u0026gt;(JsonObject, JConstants::Version); The GetIfExists() function uses templates which are specialized for each data type (to save space only the FString and bool specializations are shown below). First the struct JsonEnum\u0026lt;T\u0026gt; maps from a c++ data type such as FString to the corresponding EJson enumeration EJson::String.\ntemplate\u0026lt; typename T \u0026gt; struct JsonEnum; template \u0026lt;\u0026gt; struct JsonEnum\u0026lt;FString\u0026gt; { const static EJson Type = EJson::String; }; template \u0026lt;\u0026gt; struct JsonEnum\u0026lt;bool\u0026gt; { const static EJson Type = EJson::Boolean; }; Then the struct Extractor\u0026lt;T\u0026gt; maps from a c++ data type such as FString to the corresponding GetXXX() call on the FJsonObject like this:\ntemplate\u0026lt; typename T \u0026gt; struct Extractor; template \u0026lt;\u0026gt; struct Extractor\u0026lt;FString\u0026gt; { FString operator()(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { return JsonObject-\u0026gt;GetStringField(PropertyName); } }; template \u0026lt;\u0026gt; struct Extractor\u0026lt;bool\u0026gt; { bool operator()(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { return JsonObject-\u0026gt;GetBoolField(PropertyName); } }; And finally the GetIfExists() function uses the two above templates:\ntemplate\u0026lt; typename T \u0026gt; T GetIfExists(const TSharedPtr\u0026lt;FJsonObject\u0026gt;\u0026amp; JsonObject, const FString\u0026amp; PropertyName) { if (JsonObject \u0026amp;\u0026amp; JsonObject-\u0026gt;HasTypedField\u0026lt; JsonEnum\u0026lt;T\u0026gt;::Type \u0026gt;(PropertyName)) { return Extractor\u0026lt;T\u0026gt;{}(JsonObject, PropertyName); } return T(); } Reading arrays of child objects When the Json object has a child array of other objects, this can be accessed using the GetArrayField method:\nif (JsonObject-\u0026gt;HasTypedField\u0026lt;EJson::Array\u0026gt;(JConstants::Settings)) { const TArray\u0026lt;TSharedPtr\u0026lt;FJsonValue\u0026gt;\u0026gt;\u0026amp; Settings = JsonObject-\u0026gt;GetArrayField(JConstants::Settings); for ( const TSharedPtr\u0026lt;FJsonValue\u0026gt;\u0026amp; Setting : Settings) { const TSharedPtr\u0026lt;FJsonObject\u0026gt; Object = Setting-\u0026gt;AsObject(); if (Object) { TSharedRef\u0026lt;FPresetSetting\u0026gt; PresetSetting = MakeShared\u0026lt;FPresetSetting\u0026gt;(); PresetSetting-\u0026gt;ClassConfigName = GetIfExists\u0026lt;FString\u0026gt;( Object, JConstants::ClassConfig); PresetSetting-\u0026gt;ClassDisplayName = GetIfExists\u0026lt;FString\u0026gt;(Object, JConstants::ClassDisplay); PresetSetting-\u0026gt;PropertyDisplayName = GetIfExists\u0026lt;FString\u0026gt;(Object, JConstants::DisplayName); ... } } } ","date":"2022-06-24","permalink":"https://johnjfarrow.github.io/posts/basicsofjson/","tags":["unreal engine","json","c++"],"title":"Using the Unreal Engine Json classes"},{"content":"Reflection Reflection is the ability to inspect c++ classes and objects at runtime and gather information about their data types and properties. Normally C++ does not maintain programmer-accessible information about, say, what members a struct or class has. Unreal Engine uses macros such as UCLASS and UPROPERTY to create information about classes, structs, methods, properties, and to make that information available to C++ at runtime.\nThis enables a program to introspect an object and find out, for example, what properties that object has, what the types of those properties are, and given an instance of that object, what the values of those properties are.\nBackground The notes here were made in the course of creating a plugin which checks a project configuration against a known-good collection of configuration settings, for example to check that all the settings required for hardware raytracing have their correct values, and have to options to display and change the current settings, as shown here:\nThis plugin needs to:\nidentify Unreal Engine classes which are used for project settings identify properties on those classes retrieve the current values of those properties change the current values of those properties The classes which Unreal Engine uses for project settings cannot be hard-coded because they depend on which plugins the user has loaded; so reflection is a good way of retrieving the required information.\nCreating Reflection Data Unreal Engine uses macros which are embedded in the c++ class declarations to create reflection data.\nA class defined using the UCLASS macro like the one below will have reflection data:\nUCLASS(config=Engine, defaultconfig) class UWindowsTargetSettings : public UObject { ... } The UCLASS macro has many parameters which control how Unreal Engine treats the class, for example whether it can be accessed using Blueprints. The parameters are defined in https://docs.unrealengine.com. At runtime these parameters can be retrieved from using a c++ API.\nOther c++ objects such as enum declarations, functions and properties have corresponding macros (namely UENUM, UFUNCTION and UPROPERTY) which are used in a similar way as the UCLASS macro.\nAccessing Reflection Data Class Information The entry point for reflection data is using iterators. To iterate over the reflection data for all classes which are derived from UObject you use this:\nfor (FThreadSafeObjectIterator Itr(UObject::StaticClass()); Itr; ++Itr) { UClass* Class = Itr-\u0026gt;GetClass(); ... } To limit the search to classes which are derived from a base class such as UDeveloperSettings you do this:\nfor (FThreadSafeObjectIterator Itr(UDeveloperSettings::StaticClass()); Itr; ++Itr) { UClass* Class = Itr-\u0026gt;GetClass(); ... } UClass Having obtained a UClass* using an iterator as described above, you can do various useful things including:\nAction Function check if the class is a blueprint or a c++ class Class-\u0026gt;IsNative() retrieve the class name Class-\u0026gt;GetName(ClassName) retrieve the config file where class settings are saved Class-\u0026gt;ClassConfigName retrieve metadata such as the label on the UI settings screen Class-\u0026gt;GetMetaDataText(\u0026ldquo;DisplayName\u0026rdquo;) Properties From a UClass* you can retrieve information about the properties, also using a iterator like so:\nfor (TFieldIterator\u0026lt;FProperty\u0026gt; PropIt(Class); PropIt; ++PropIt) { FProperty* Property = *PropIt; ... } Similar to dealing with a property, you can call various functions on a property:\nAction Function retrieve the property name Property-\u0026gt;GetName() retrieve metadata such as the label on the UI settings screen Property-\u0026gt;GetMetaDataText(\u0026ldquo;DisplayName\u0026rdquo;) You can retrieve elements of the UPROPERTY declaration. For example given this property declaration:\nUPROPERTY(config, EditAnywhere, Category = Shadows, meta = ( ConsoleVariable = \u0026quot;r.Shadow.Virtual.Enable\u0026quot;, DisplayName = \u0026quot;Shadow Map Method\u0026quot;, ToolTip = \u0026quot;Select the primary shadow mapping method.\u0026quot;)) TEnumAsByte\u0026lt;EShadowMapMethod::Type\u0026gt; ShadowMapMethod; you can test if the property is a config property declared with UPROPERTY(config) like this:\nEPropertyFlags Flags = Property-\u0026gt;PropertyFlags; if ((Flags \u0026amp; EPropertyFlags::CPF_Config) != 0) and retrieve variables from the metadata like this:\nconst FText DisplayName = Property-\u0026gt;GetMetaDataText(\u0026quot;DisplayName\u0026quot;); const FText ConsoleVariable = Property-\u0026gt;GetMetaDataText(\u0026quot;ConsoleVariable\u0026quot;); The type of a property can be retrieved by either:\ncalling Property-\u0026gt;GetCPPType() to return the type as a string, or testing it by casting like so: if (const FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { ... } Looking at the Unreal Engine source code casting seems to be the preferred way.\nReading Property Values The code examples above deal with the static reflection data for properties and classes. They do not need a specific instance of a class object to access that data, it is accessed from static instances such as UDeveloperSettings::StaticClass().\nTo extract a property value from an actual instance of a class requires retrieving the memory address where that property value is stored. Given an instance of a class and a property pointer retrieved as shown above, we can do this to find the memory address where the property is stored:\nFProperty* Property = ... UClass* Class = ... const uint8* PropertyAddr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;uint8\u0026gt;(Class); we can then cast the property pointer to its derived property class and retrieve the property value using the data address:\nif (FStrProperty* StringProperty = CastField\u0026lt;FStrProperty\u0026gt;(Property)) { Value = StringProperty-\u0026gt;GetPropertyValue(PropertyAddr); } Some types of property require more work, for instance numeric properties can be different types, as shown here:\nif (FNumericProperty* NumericProperty = CastField\u0026lt;FNumericProperty\u0026gt;(Property)) { if (NumericProperty-\u0026gt;IsFloatingPoint()) { Value = FString::SanitizeFloat(NumericProperty-\u0026gt;GetFloatingPointPropertyValue(PropertyAddr)); } else if (NumericProperty-\u0026gt;IsInteger()) { Value = FString::FromInt(NumericProperty-\u0026gt;GetSignedIntPropertyValue(PropertyAddr)); } } Enum properties have functions for getting a string representation derived from the enum value, like so:\nif (FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { UEnum* EnumDef = EnumProperty-\u0026gt;GetEnum(); FNumericProperty* UnderlyingProperty = EnumProperty-\u0026gt;GetUnderlyingProperty(); int32 IntValue = UnderlyingProperty-\u0026gt;GetSignedIntPropertyValue(PropertyAddr); Value = EnumDef-\u0026gt;GetAuthoredNameStringByValue(IntValue); } For an enum declared like this:\nenum class EDefaultGraphicsRHI : uint8 { DefaultGraphicsRHI_Default = 0 UMETA(DisplayName = \u0026quot;Default\u0026quot;), DefaultGraphicsRHI_DX11 = 1 UMETA(DisplayName = \u0026quot;DirectX 11\u0026quot;), DefaultGraphicsRHI_DX12 = 2 UMETA(DisplayName = \u0026quot;DirectX 12\u0026quot;), DefaultGraphicsRHI_Vulkan = 3 UMETA(DisplayName = \u0026quot;Vulkan\u0026quot;), }; with a property value of EDefaultGraphicsRHI::DefaultGraphicsRHI_DX11 the GetSignedIntPropertyValue() call will return 1 and the GetAuthoredNameStringByValue(1) call will return the string \u0026ldquo;DefaultGraphicsRHI_DX11\u0026rdquo;.\nWriting Property Values The process of writing property values is much the same as reading them, firstly we need to get the address where the data is stored like so:\nFProperty* Property = ... UClass* Class = ... const uint8* PropertyAddr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;uint8\u0026gt;(Class); Again we cast the property pointer to see what type it is and set the value using the address:\nif (FNumericProperty* NumericProperty = CastField\u0026lt;FNumericProperty\u0026gt;(Property)) { if (NumericProperty-\u0026gt;IsFloatingPoint()) { NumericProperty-\u0026gt;SetFloatingPointPropertyValue(PropertyAddr, NewFloatValue); } } Each type of property has different methods for setting it. For example setting an enum property from a string value involves calling GetIndexByNameString() to get the int representation of that string:\nif (FEnumProperty* EnumProperty = CastField\u0026lt;FEnumProperty\u0026gt;(Property)) { UEnum* EnumDef = EnumProperty-\u0026gt;GetEnum(); FNumericProperty* UnderlyingNumericProperty = EnumProperty-\u0026gt;GetUnderlyingProperty(); int64 NewIntValue = EnumDef -\u0026gt;GetIndexByNameString(PushedValue, EGetByNameFlags::None); if (NewIntValue == -1) { UnderlyingNumericProperty-\u0026gt;SetIntPropertyValue(PropertyAddr, NewIntValue); } } ","date":"2022-06-22","permalink":"https://johnjfarrow.github.io/posts/usingreflection/","tags":["unreal engine","reflection","c++"],"title":"Using Reflection in Unreal Engine"},{"content":"This is a brief guide to downloading and building UE5 using git command line tools and Visual Studio 2022.\nAccounts Github Account If you don\u0026rsquo;t have a github account, go to github.com and make one.\nEpic Games Account If you don\u0026rsquo;t have an Epic Games account, go to epicgames.com/register and create one.\nConnecting the Epic Games account to the Github account You need to connect your Epic Games account to your github account so you can get access to Epic\u0026rsquo;s github repositories.\nTo do this:\nsign into your Epic Games account at epicgames.com click on your username near the top right corner of the page and select \u0026ldquo;Account\u0026rdquo; from the dropdown menu click on \u0026ldquo;Connections\u0026rdquo; in the list of options on the left side of the page select \u0026ldquo;Accounts\u0026rdquo; from the tab bar with the \u0026ldquo;Apps\u0026rdquo; and \u0026ldquo;Accounts\u0026rdquo; options under the github icon click the \u0026ldquo;Connect\u0026rdquo; button. This will guide you through a series of steps to connect your Epic Games and github accounts Software Installing git If you do not already have the git commandline tools installed, install them from git-scm.com/downloads.\nInstalling Visual Studio 2022 If you do not already have Visual Studio 2022 installed, install it from visualstudio.microsoft.com.\nInstall at least these options:\nand\nConfiguring Visual Studio 2022 Some useful options you might like to set are:\nDisable Hot Reload In Tools|Options|Debugging|.NET/C++ Hot Reload disable all the Hot Reload options:\nSet Solution Configurations dropdown width Change the width of the Solution Configurations dropdown to handle the longer names used by UE:\nright-click on the toolbar shown below, select \u0026ldquo;Customize\u0026rdquo; change to the \u0026ldquo;Commands\u0026rdquo; tab\nselect \u0026ldquo;Toolbar\u0026rdquo; in the top radio button group\nchange the toolbar value from \u0026ldquo;Build\u0026rdquo; to \u0026ldquo;Standard\u0026rdquo; like so:\nin the preview panel select \u0026ldquo;System Configurations\u0026rdquo; click the \u0026ldquo;Modify Selection\u0026rdquo; button change the width to 130 press \u0026ldquo;OK\u0026rdquo; and \u0026ldquo;Close\u0026rdquo;. The toolbar will now have changed to Turn on Indexing To make sure indexed searching is enabled, go to Tools \u0026gt; Options \u0026gt; Environment \u0026gt; Preview Features and verify that “Enable indexing for faster find experience” is checked.\nSee devblogs.microsoft.com.\nDownloading \u0026amp; Building Downloading the source Make a new directory such as c:\\work, and change into it.\nClone the Unreal Engine source repository:\ngit clone https://github.com/EpicGames/UnrealEngine.git UnrealSource where UnrealSource is the name of a new directory to which the source will be downloaded.\nInstalling the UnrealVS plugin for Visual Studio UnrealVS is a Visual Studio plugin from Epic. It is included in the UE source code. Exit Visual Studio if needed and install the file [UnrealEngineSource]\\Engine\\Extras\\UnrealVS\\VS2022\\UnrealVS.vsix by double clicking it.\nChoosing a branch This page github.com/EpicGames/UnrealEngine/branches lists significant branches including:\nrelease - the latest released version of UE ue5-main - most up to date - this is being continuously updated and won\u0026rsquo;t necessarily build or run on any given day. Change into the new source directory created by the git clone command.\nRun git checkout [branch-name] for whichever branch you chose to build.\nBuilding This is a summary of information from [https://github.com/EpicGames/UnrealEngine/tree/master].\nChange to the directory in which you downloaded the UE source code and run this command to download and install prerequisites required to build UE - it might take a while:\nSetup.bat then run\nGenerateProjectFiles.bat -2022 Opening the Solution The above commands will create the file UE5.sln in the current directory, open it in Visual Studio and:\nchange the Solution Configuration dropdown to \u0026ldquo;Development Editor\u0026rdquo; change the Solution Platform to \u0026ldquo;Win64\u0026rdquo; right click the UE5 project in the solution explorer and choose \u0026ldquo;Build\u0026rdquo;. This will take some time to complete. On a Ryzen 5950x 16 core machine using an M.2 SSD it took 37 minutes.\nRunning Unreal In the solution explorer right-click \u0026ldquo;UE5\u0026rdquo; under the \u0026ldquo;Engine\u0026rdquo; entry at the top and select \u0026ldquo;Set as Startup Project\u0026rdquo;.\nPress F5 to run UE\nEarlier versions These instructions will work for Unreal 4.27 and Visual Studio 2022. Make sure you clone the git repository then checkout the 4.27 branch before you run Setup.bat or GenerateProjectFiles.bat.\nThe solution file created will be called UE4.sln not UE5.sln.\n","date":"2022-06-21","permalink":"https://johnjfarrow.github.io/posts/buildfromsource/","tags":["unreal engine","build","c++"],"title":"Building Unreal Engine From Source"}]