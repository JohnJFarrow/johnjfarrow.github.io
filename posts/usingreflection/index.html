<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico><title>Using Reflection in Unreal Engine - Unreal Engine Development Notes</title><meta name=author content="John Farrow"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="unreal engine,reflection,c++"><meta property="og:title" content="Using Reflection in Unreal Engine"><meta name=twitter:title content="Using Reflection in Unreal Engine"><meta property="og:type" content="article"><meta property="og:url" content="https://johnjfarrow.github.io/posts/usingreflection/"><meta property="og:description" content="Notes on using the Unreal Engine reflection system"><meta name=twitter:description content="Notes on using the Unreal Engine reflection system"><meta property="og:image" content="https://johnjfarrow.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://johnjfarrow.github.io/img/og.png"><meta property="article:published_time" content="2022-06-22T10:27:06+12:00"><meta property="article:modified_time" content="2022-06-22T10:27:06+12:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://johnjfarrow.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://johnjfarrow.github.io>Unreal Engine Development Notes</a>
<span class=title-sub>John Farrow</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://johnjfarrow.github.io/posts/usingreflection/>Using Reflection in Unreal Engine</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-06-22</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/unreal-engine>unreal engine</a>&nbsp;<a href=/tags/reflection>reflection</a>&nbsp;<a href=/tags/c++>c++</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=reflection>Reflection</h2><p>Reflection is the ability to inspect c++ classes and objects at runtime and gather information about
their data types and properties. Normally C++
does not maintain programmer-accessible information about, say, what members a struct or
class has. Unreal Engine uses macros such as UCLASS and UPROPERTY to create information
about classes, structs, methods, properties, and to make
that information available to C++ at runtime.</p><p>This enables a program to introspect an object and find out, for example, what properties
that object has, what the types of those properties are, and given an instance of that object,
what the values of those properties are.</p><h2 id=background>Background</h2><p>The notes here were made in the course of
creating a plugin which checks a project configuration
against a known-good collection of configuration settings, for
example to check that all the settings required for hardware
raytracing have their correct values, and have to options to display and change
the current settings, as shown here:</p><p><img class=img-zoomable src=/images/reflection_1.png alt></p><p>This plugin needs to:</p><ul><li>identify Unreal Engine classes which are used for project settings</li><li>identify properties on those classes</li><li>retrieve the current values of those properties</li><li>change the current values of those properties</li></ul><p>The classes which Unreal Engine uses for project settings cannot be hard-coded
because they depend on which plugins the user has loaded; so reflection
is a good way of retrieving the required information.</p><h2 id=creating-reflection-data>Creating Reflection Data</h2><p>Unreal Engine uses macros which are embedded in the c++ class declarations to
create reflection data.</p><p>A class defined using the UCLASS macro like the one below will have reflection data:</p><pre><code class=language-cpp>UCLASS(config=Engine, defaultconfig)
class UWindowsTargetSettings 
	: public UObject
{
    ...
}
</code></pre><p>The UCLASS macro has many parameters which control how Unreal Engine treats the class, for
example whether it can be accessed using Blueprints. The parameters are defined
in <a href=https://docs.unrealengine.com/5.0/en-US/gameplay-classes-in-unreal-engine/ target=_blank>https://docs.unrealengine.com</a>. At
runtime these parameters can be retrieved from using a c++ API.</p><p>Other c++ objects such as enum declarations, functions and properties have corresponding
macros (namely UENUM, UFUNCTION and UPROPERTY) which are used in a similar way
as the UCLASS macro.</p><h2 id=accessing-reflection-data>Accessing Reflection Data</h2><h3 id=class-information>Class Information</h3><p>The entry point for reflection data is using iterators. To iterate
over the reflection data for all classes which are derived from UObject
you use this:</p><pre><code class=language-cpp>for (FThreadSafeObjectIterator Itr(UObject::StaticClass()); Itr; ++Itr)
{
	UClass* Class = Itr-&gt;GetClass();
    ...
}
</code></pre><p>To limit the search to classes which are derived from a
base class such as UDeveloperSettings you do this:</p><pre><code class=language-cpp>for (FThreadSafeObjectIterator Itr(UDeveloperSettings::StaticClass()); Itr; ++Itr)
{
	UClass* Class = Itr-&gt;GetClass();
    ...
}
</code></pre><h4 id=uclass>UClass</h4><p>Having obtained a UClass* using an iterator as described above, you can do various useful
things including:</p><table><thead><tr><th style=text-align:left>Action</th><th style=text-align:left>Function</th></tr></thead><tbody><tr><td style=text-align:left>check if the class is a blueprint or a c++ class</td><td style=text-align:left>Class->IsNative()</td></tr><tr><td style=text-align:left>retrieve the class name</td><td style=text-align:left>Class->GetName(ClassName)</td></tr><tr><td style=text-align:left>retrieve the config file where class settings are saved</td><td style=text-align:left>Class->ClassConfigName</td></tr><tr><td style=text-align:left>retrieve metadata such as the label on the UI settings screen</td><td style=text-align:left>Class->GetMetaDataText(&ldquo;DisplayName&rdquo;)</td></tr></tbody></table><h4 id=properties>Properties</h4><p>From a UClass* you can retrieve information about the properties, also using a iterator like so:</p><pre><code class=language-cpp>for (TFieldIterator&lt;FProperty&gt; PropIt(Class); PropIt; ++PropIt)
{
	FProperty* Property = *PropIt;
    ...
}
</code></pre><p>Similar to dealing with a property, you can call various functions on a property:</p><table><thead><tr><th style=text-align:left>Action</th><th style=text-align:left>Function</th></tr></thead><tbody><tr><td style=text-align:left>retrieve the property name</td><td style=text-align:left>Property->GetName()</td></tr><tr><td style=text-align:left>retrieve metadata such as the label on the UI settings screen</td><td style=text-align:left>Property->GetMetaDataText(&ldquo;DisplayName&rdquo;)</td></tr></tbody></table><p>You can retrieve elements of the UPROPERTY declaration. For example given this property
declaration:</p><pre><code class=language-cpp>UPROPERTY(config, EditAnywhere, Category = Shadows, meta = (
    ConsoleVariable = &quot;r.Shadow.Virtual.Enable&quot;, 
    DisplayName = &quot;Shadow Map Method&quot;,
    ToolTip = &quot;Select the primary shadow mapping method.&quot;))
    TEnumAsByte&lt;EShadowMapMethod::Type&gt; ShadowMapMethod;
</code></pre><p>you can test if the property is a config property declared with UPROPERTY(config) like this:</p><pre><code class=language-cpp>EPropertyFlags Flags = Property-&gt;PropertyFlags;
if ((Flags &amp; EPropertyFlags::CPF_Config) != 0)
</code></pre><p>and retrieve variables from the metadata like this:</p><pre><code>const FText DisplayName = Property-&gt;GetMetaDataText(&quot;DisplayName&quot;);
const FText ConsoleVariable = Property-&gt;GetMetaDataText(&quot;ConsoleVariable&quot;);
</code></pre><p>The type of a property can be retrieved by either:</p><ul><li>calling <code>Property->GetCPPType()</code> to return the type as a string, or</li><li>testing it by casting like so:</li></ul><pre><code class=language-cpp>if (const FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
    ...
}
</code></pre><p>Looking at the Unreal Engine source code casting seems to be the preferred way.</p><h3 id=reading-property-values>Reading Property Values</h3><p>The code examples above deal with the static reflection data for properties and classes. They
do not need a specific instance of a class object to access that data, it is accessed from
static instances such as <code>UDeveloperSettings::StaticClass()</code>.</p><p>To extract a property value from an actual instance of a class requires retrieving the
memory address where that property value is stored. Given an instance of a class
and a property pointer retrieved as shown above, we can do this to find the
memory address where the property is stored:</p><pre><code class=language-cpp>FProperty* Property = ...
UClass* Class = ...
const uint8* PropertyAddr = Property-&gt;ContainerPtrToValuePtr&lt;uint8&gt;(Class);
</code></pre><p>we can then cast the property pointer to its derived property class and retrieve the
property value using the data address:</p><pre><code class=language-cpp>if (FStrProperty* StringProperty = CastField&lt;FStrProperty&gt;(Property))
{
    Value = StringProperty-&gt;GetPropertyValue(PropertyAddr);
}
</code></pre><p>Some types of property require more work, for instance numeric properties can be different
types, as shown here:</p><pre><code class=language-cpp>if (FNumericProperty* NumericProperty = CastField&lt;FNumericProperty&gt;(Property))
{
    if (NumericProperty-&gt;IsFloatingPoint())
    {
        Value = FString::SanitizeFloat(NumericProperty-&gt;GetFloatingPointPropertyValue(PropertyAddr));
    }
	else if (NumericProperty-&gt;IsInteger())
    {
        Value = FString::FromInt(NumericProperty-&gt;GetSignedIntPropertyValue(PropertyAddr));
    }
}
</code></pre><p>Enum properties have functions for getting a string representation derived
from the enum value, like so:</p><pre><code class=language-cpp>if (FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
    UEnum* EnumDef = EnumProperty-&gt;GetEnum();
    FNumericProperty* UnderlyingProperty = EnumProperty-&gt;GetUnderlyingProperty();
    int32 IntValue = UnderlyingProperty-&gt;GetSignedIntPropertyValue(PropertyAddr);
    Value = EnumDef-&gt;GetAuthoredNameStringByValue(IntValue);
}
</code></pre><p>For an enum declared like this:</p><pre><code class=language-cpp>enum class EDefaultGraphicsRHI : uint8
{
    DefaultGraphicsRHI_Default = 0 UMETA(DisplayName = &quot;Default&quot;),
    DefaultGraphicsRHI_DX11 = 1 UMETA(DisplayName = &quot;DirectX 11&quot;),
	DefaultGraphicsRHI_DX12 = 2 UMETA(DisplayName = &quot;DirectX 12&quot;),
	DefaultGraphicsRHI_Vulkan = 3 UMETA(DisplayName = &quot;Vulkan&quot;),
};
</code></pre><p>with a property value of <code>EDefaultGraphicsRHI::DefaultGraphicsRHI_DX11</code> the GetSignedIntPropertyValue() call will return 1
and the GetAuthoredNameStringByValue(1) call will return the string &ldquo;DefaultGraphicsRHI_DX11&rdquo;.</p><h3 id=writing-property-values>Writing Property Values</h3><p>The process of writing property values is much the same as reading them, firstly we need to get the address
where the data is stored like so:</p><pre><code class=language-cpp>FProperty* Property = ...
UClass* Class = ...
const uint8* PropertyAddr = Property-&gt;ContainerPtrToValuePtr&lt;uint8&gt;(Class);
</code></pre><p>Again we cast the property pointer to see what type it is and
set the value using the address:</p><pre><code class=language-cpp>if (FNumericProperty* NumericProperty = CastField&lt;FNumericProperty&gt;(Property))
{
    if (NumericProperty-&gt;IsFloatingPoint())
	{
		NumericProperty-&gt;SetFloatingPointPropertyValue(PropertyAddr, NewFloatValue);
    }
}
</code></pre><p>Each type of property has different methods for setting it. For example
setting an enum property from a string value involves calling
GetIndexByNameString() to get the int representation of that string:</p><pre><code class=language-cpp>if (FEnumProperty* EnumProperty = CastField&lt;FEnumProperty&gt;(Property))
{
	UEnum* EnumDef = EnumProperty-&gt;GetEnum();
	FNumericProperty* UnderlyingNumericProperty = 
       EnumProperty-&gt;GetUnderlyingProperty();

	int64 NewIntValue = EnumDef
       -&gt;GetIndexByNameString(PushedValue, EGetByNameFlags::None);

	if (NewIntValue == -1)
	{
        UnderlyingNumericProperty-&gt;SetIntPropertyValue(PropertyAddr, NewIntValue);
    }
}
</code></pre></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/blender/>blender</a></span>
<span><a href=/tags/blueprint/>blueprint</a></span>
<span><a href=/tags/blueprints/>blueprints</a></span>
<span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/chaos/>chaos</a></span>
<span><a href=/tags/ffmpeg/>ffmpeg</a></span>
<span><a href=/tags/gif/>gif</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/physics/>physics</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/rotation/>rotation</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#reflection>Reflection</a></li><li><a href=#background>Background</a></li><li><a href=#creating-reflection-data>Creating Reflection Data</a></li><li><a href=#accessing-reflection-data>Accessing Reflection Data</a><ul><li><a href=#class-information>Class Information</a></li><li><a href=#reading-property-values>Reading Property Values</a></li><li><a href=#writing-property-values>Writing Property Values</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/johnjfarrow target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/johnjfarrow target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/blender/>blender</a></span>
<span><a href=/tags/blueprint/>blueprint</a></span>
<span><a href=/tags/blueprints/>blueprints</a></span>
<span><a href=/tags/build/>build</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/chaos/>chaos</a></span>
<span><a href=/tags/ffmpeg/>ffmpeg</a></span>
<span><a href=/tags/gif/>gif</a></span>
<span><a href=/tags/json/>json</a></span>
<span><a href=/tags/physics/>physics</a></span>
<span><a href=/tags/reflection/>reflection</a></span>
<span><a href=/tags/rotation/>rotation</a></span>
<span><a href=/tags/slate/>slate</a></span>
<span><a href=/tags/unreal-engine/>unreal engine</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#reflection>Reflection</a></li><li><a href=#background>Background</a></li><li><a href=#creating-reflection-data>Creating Reflection Data</a></li><li><a href=#accessing-reflection-data>Accessing Reflection Data</a><ul><li><a href=#class-information>Class Information</a></li><li><a href=#reading-property-values>Reading Property Values</a></li><li><a href=#writing-property-values>Writing Property Values</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2022
<a href=https://johnjfarrow.github.io>John Farrow</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>