(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{308:function(e,t,a){"use strict";a.r(t);var r=a(14),i=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",[e._v(e._s(this.$page.title))]),e._v(" "),a("h3",{attrs:{id:"get-the-ffmpeg-plugin-project-from-perforce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-the-ffmpeg-plugin-project-from-perforce"}},[e._v("#")]),e._v(" Get the ffmpeg plugin project from Perforce")]),e._v(" "),a("h3",{attrs:{id:"make-a-subsystem"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#make-a-subsystem"}},[e._v("#")]),e._v(" Make a subsystem")]),e._v(" "),a("p",[e._v("To wrap access to ffmpeg"),a("br"),e._v("\nMaybe a singleton"),a("br"),e._v("\n(Maybe in BeginPlay) an actor can get a reference to a ffmpeg interface\nwhich runs on worker thread")]),e._v(" "),a("h3",{attrs:{id:"make-an-input-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#make-an-input-queue"}},[e._v("#")]),e._v(" Make an input queue")]),e._v(" "),a("p",[e._v("Similar to https://github.com/TimmHess/UnrealImageCapture where textures which have been\nretrived from the viewport or camera can be pushed on a queue")]),e._v(" "),a("p",[e._v("A worker thread can poll the queue or react to it being updated (using events)\nand get a job from the queue")]),e._v(" "),a("p",[e._v("Jobs would have:")]),e._v(" "),a("ul",[a("li",[e._v("a texture")]),e._v(" "),a("li",[e._v("a time captured")]),e._v(" "),a("li",[e._v("maybe a sequence number")]),e._v(" "),a("li",[e._v("maybe a destination to support multiple outputs")])]),e._v(" "),a("h3",{attrs:{id:"worker-thread-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker-thread-processing"}},[e._v("#")]),e._v(" Worker thread processing")]),e._v(" "),a("p",[e._v("Use ffmpeg to")]),e._v(" "),a("ul",[a("li",[e._v("read input texture")]),e._v(" "),a("li",[e._v("determine format")]),e._v(" "),a("li",[e._v("decode format")]),e._v(" "),a("li",[e._v("decode raw data")]),e._v(" "),a("li",[e._v("encode to h.264")]),e._v(" "),a("li",[e._v("encode to mpegts container")])]),e._v(" "),a("h3",{attrs:{id:"ffmpeg-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ffmpeg-state"}},[e._v("#")]),e._v(" ffmpeg state")]),e._v(" "),a("p",[e._v("For each destination there would be:")]),e._v(" "),a("ul",[a("li",[e._v("the srt url")]),e._v(" "),a("li",[e._v("maybe a file url alternative")]),e._v(" "),a("li",[e._v("ffmpeg objects for the container and output streams and associated contexts")])]),e._v(" "),a("h3",{attrs:{id:"blueprint-access-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blueprint-access-object"}},[e._v("#")]),e._v(" Blueprint access object")]),e._v(" "),a("p",[e._v("Have an FFMPEG object with these functions:")]),e._v(" "),a("ul",[a("li",[e._v("configure - would take an FFMPEG Configuration node")]),e._v(" "),a("li",[e._v("start queue processing")]),e._v(" "),a("li",[e._v("clear queue")]),e._v(" "),a("li",[e._v("stop queue processing")]),e._v(" "),a("li",[e._v("to add a texture")])]),e._v(" "),a("p",[e._v("Have an FFMPEG Configuration node which would configure the")]),e._v(" "),a("ul",[a("li",[e._v("input container format")]),e._v(" "),a("li",[e._v("input data format")]),e._v(" "),a("li",[e._v("conversion parameters - presets")]),e._v(" "),a("li",[e._v("output data format  (h.264 h.265)")]),e._v(" "),a("li",[e._v("output container format (mpegts)")]),e._v(" "),a("li",[e._v("output destination - srt or file")])]),e._v(" "),a("h3",{attrs:{id:"nice-to-haves"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nice-to-haves"}},[e._v("#")]),e._v(" nice to haves")]),e._v(" "),a("ul",[a("li",[e._v("integration into Unreal stats for performance timings")]),e._v(" "),a("li",[e._v("proper integration with Unreal threading")])])])}),[],!1,null,null,null);t.default=i.exports}}]);